<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-09 04:52:43 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-13 21:49:31 +0000"/><title>MC: Ch 06 -- Working Class</title></head><body><hr/><div><font style="font-size: 12px;" face="Times New Roman"><span style="font-weight: bold;">McConnell: Chapter 6 — Working Classes</span><br/></font></div><hr/><ul><li><font style="font-size: 12px;" face="Times New Roman">Classes are a primary tool for complexity management.</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Class Foundations: Abstract Data Types (ADTs)</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">An abstract data type is a collection of data and operations that work on that data.</font></li><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Benefits of using ADTs:</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Hiding implementation details</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Changes don’t affect the whole program</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">You can make the interface more informative</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">It’s easier to improve performance</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">The program is more obviously correct</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">The program becomes more self documenting</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">You don’t have to pass data all over your program</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">You’re able to work with real-world entities rather than with low-level implementation structures</span>.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Try to make the names of classes and access routines independent of how the data is stored, and refer to the abstract data type instead.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Good class interfaces</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Present a consistent level of abstraction in the class interface</span>. </font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Each class should implement one and only one ADT</font></li><li><font style="font-size: 12px;" face="Times New Roman">If you use inheritance, make sure the child class satisfies the “is a” relationship with the parent</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Be sure you understand what abstraction the class is implementing</span>. When you have to choose between two similar abstractions, make sure you choose the right one.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Provide services in paris with their opposites</span>. If you have an operation that turns a light on, you will probably want one that turns it off. Check each public routine to determine if you need its complement.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Move unrelated information to another class</span>. If half of the class’s routines work with half the class’s data and half with the other data, then separate the class into two distinct classes.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Make interfaces programmatic rather than semantic when possible</span>. Each interface has a programmatic part and a semantic part.</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Programmatic part consists of the data types and other attributes of the interface that can be enforced by the compiler</font></li><li><font style="font-size: 12px;" face="Times New Roman">Semantic part of the interface consists of the assumptions about how the interface will be used, which cannot be enforced by the compiler.</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">The semantic part must be clearly documented, but interfaces should be minimally dependent on documentation.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Better apply compile-time checkable solutions to semantic parts like assertions or other techniques.</font></li></ul></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Beware of erosion of the interface’s abstraction under modification</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Don’t add public members that are inconsistent with the interface abstraction</span>. Each time you add a routine to a class interface ask “Is this routine consistent with the abstraction provided by the existing interface?”</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Consider abstraction and cohesion together</span>. These two concepts are related.</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Good Encapsulation</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Minimize accessibility of classes and members</span>. Favor the strictest level of privacy that still works. If exposing the routine is consistent with the abstraction, however, it’s probably fine to expose it.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Don’t expose member data in public</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Avoid putting private implementation details into a class’s interface</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Don’t make assumptions about the class’s users</span>. You cannot make the assumption about how your interface will or will not be used.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Avoid friend classes</span>. They violate the principle of encapsulation.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Don’t put a routine into the public interface just because it uses only public routines</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Favor read-time convenience to write-time convenience</span>. Code is read more than it is written.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Be very, very wary of </span><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">semantic violations of encapsulation</span>. </font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Here are some examples of how encapsulation can be broken semantically:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Not calling Class A’s InitializeOperations() routine because you know that Class A’s PerformFirstOperation() routine calls it automatically</font></li><li><font style="font-size: 12px;" face="Times New Roman">Not calling the database.Connect() routine before you call employee.Retrieve(database) because you know that the employee.Retreive() function will connect to the database if there isn’ already a connection</font></li><li><font style="font-size: 12px;" face="Times New Roman">Using Class B’s MAXIMUM_ELEMENTS constant instead of using ClassA.MAXIMUM_ELEMENTS, because you know that they’re both equal to the same value.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">The problem with each of these examples is that they make the client code dependent on implementation specifics that are not part of the interface.</font></li><li><font style="font-size: 12px;" face="Times New Roman">If you don’t understand somebody’s interface, ask them about it and make no assumptions outside the interface. Consequently, the implementor of the interface should not respond to you directly but change documentation/interface and ask if you can understand the interface after the changes. If this is not done, there will be semantical assumptions in your use of the interface by definition.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Watch for coupling that is too tight</span>. </font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Minimize accessibility of classes and members</font></li><li><font style="font-size: 12px;" face="Times New Roman">Avoid friend classes</font></li><li><font style="font-size: 12px;" face="Times New Roman">Make data private rather than protected in a base class to make derived classes less tightly coupled to the base class</font></li><li><font style="font-size: 12px;" face="Times New Roman">Avoid exposing member data in a class’s public interface</font></li><li><font style="font-size: 12px;" face="Times New Roman">Be wary of semantic violations of encapsulation</font></li><li><font style="font-size: 12px;" face="Times New Roman">Observe the <span style="font-style: italic;">Law of Demeter</span></font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Design and Implementation Issues</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">This section discusses issues related to containment, inheritance, member functions and data, class coupling, constructors, and value-vs.-reference objects.</font></li><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Containment (“has a” relationship)</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">The idea that a class contains a primitive data element or object. Containment, not inheritance, is the work-horse technique in object-oriented programming</font></li><li><font style="font-size: 12px;" face="Times New Roman">People mention inheritance more only because it is more error-prone</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Implement “has a” through containment</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Implement “has a” through private inheritance as a last resort</span>. This way the containing class is able to access protected member functions or data of the class that’s contained. This usually tends to point to design errors that should be resolved, though.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Be critical of classes that contain more than about 7 data members</span>. If a class contains more than 7 members, it is hard for programmers to keep track of all the internal variables successfully.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Inheritance (“is a” relationship)</span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">.</span></font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Inheritance is the idea that one class is the specialization of another.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Inheritance helps avoid the need to repeat code and data in multiple locations by centralizing it within a base class.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Decisions you have to make before using inheritance:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">For each member routine, will the routine be visible to derived classes? Will it have a default implementation? Will the default implementation be overridable?</font></li><li><font style="font-size: 12px;" face="Times New Roman">For each data member, will the data ember be visible to derived classes?</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Implement “is a” through public inheritance</span>. If the derived class is not going to adhere completely to the same interface contract defined by the base class, inheritance is not the right implementation technique. Consider containment or making a change further up the inheritance hierarchy.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Design and document for inheritance or prohibit it</span>.  Inheritance adds complexity to a program, and, as such, it’s a dangerous technique. If a class isn’t designed to be inherited from, make its members non-virtual in C++, final in Java.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Adhere to the Leskov Substitution Principle (LSP)</span>. You shouldn’t inherit from a base class unless the derived class truly “is a” more specific version of the base class. Subclasses must be usable through the base class interface without the need for the user to know the difference, i.e. all the routines defined in the base class should mean the same thing when they’re used in each of the derived classes.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Be sure to inherit only what you want to inherit</span>. <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Three flavors of inherited routines</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">An abstract overridable routine</span>. Means the derived class inherits the routine’s interface but not its implementation.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">An overridable routine</span>. means that the derived class inherits the routine’s interface and a default implementation and it is allowed to override the default implementation.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">A non-overridable routine</span>. Means that the derived class inherits the routine and it’s default implementation without being able to override it.</font></li><li><font style="font-size: 12px;" face="Times New Roman">If you want to use a class’s implementation but not its interface, use containment rather than inheritance.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Don’t “override” a non-overridable member function</span>. Don’t reuse names of non-overridable base-class routines in derived classes.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Move common interfaces, data, and behavior as high as possible in the inheritance tree</span>. </font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Be suspicious of class of which there is only one instance</span>. A single instance might indicate that the design confuses objects for classes. Consider if you could just create a new object rather than a distance class.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Be suspicious of base classes of which there is only one derived class</span>. The best way to prepare for future work is not to design extra layers of base classes that <span style="font-style: italic;">might be needed some day</span>. That means not creating any more inheritance structure than is absolutely necessary.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Be suspicious of classes that override a routine and do nothing inside the derived routine</span>.This typically indicates an error in the design of the base class. Issues with overriding routines by having them do nothing:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">It violates the interface contract provided by the base class by changing its semantics</font></li><li><font style="font-size: 12px;" face="Times New Roman">This approach quickly gets out of control when you extend it to other derived classes.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Hard to maintain because base class implies nothing about the behavior of derived classes.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Avoid deep inheritance trees</span>. In practice, most people have trouble juggling more than two or three levels of inheritance in their brains at once. Deep inheritance trees are proven to increase fault rates.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Prefer polymorphism to extensive type checking</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Make all data private, not protected</span>.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Always remember that inheritance tends to work against the primary technical imperative you have as a programmer, which is to manage complexity.</font></li><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">When to use inheritance vs. when to use containment?</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">If multiple classes share common data, but not behavior, create a common object that those classes can contain</font></li><li><font style="font-size: 12px;" face="Times New Roman">If multiple classes share common behavior but not data, derive them from a common base class that defines the common routines.</font></li><li><font style="font-size: 12px;" face="Times New Roman">If multiple classes share common data and behavior, inherit from a common base class that defines the common data and routines</font></li><li><font style="font-size: 12px;" face="Times New Roman">inherit when you want the base class to control your interface; contain when you want to control your interface.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Member functions and data. Guidelines for <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">implementing member functions and data</span> effectively:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Keep number of routines in class as small as possible</span>. More class routines are associated with higher fault rate.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Disallow implicitly generated member functions and operators you don’t want</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Minimize the number of different routines called by a class</span>. Again, number of faults correlates.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Minimize indirect routine calls to other classes</span>. using account.ContactPerson().DaytimeContactInfo() is a coding horror!</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Law of Demeter</span>: If object A instantiates an object B, it can call any of object B’s routines. But it should avoid calling routines on objects provided by object B.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Minimize the extent to which a class collaborates with other classes</span>. Minimize the following:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Number of kinds of objects instantiated</font></li><li><font style="font-size: 12px;" face="Times New Roman">Number of different direct routine calls on instantiated objects</font></li><li><font style="font-size: 12px;" face="Times New Roman">Number of routine calls on objects returned by other instantiated objectects</font></li></ul></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Constructor guidelines</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Initialize all member data in all constructors, if possible</span>. Initialize all data members in all constructors is an inexpensive defensive programming practice.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Enforce the singleton property by using a private constructor</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Prefer deep copies to shallow copies until proven otherwise</span>. Deep copies rarely cause measurable performance impacts, and programmers are notoriously bad at predicting which types of objects might cause problems with deep copies.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Reasons to create a class</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Model real-world objects</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Model abstract objects</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Reduce complexity</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Isolate complexity</span>. When an error inevitably arises, it will be easier to find if it isn’t spread through the code but is localized within a class.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Hide implementation details</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Limit effects of changes</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Hide global data</span>. If you need to use global data, you can hide its implementation details behind a class interface.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Streamline parameter passing</span>. If you are passing a parameter among several routines that might indicate a need to factor those routines into a class that share the parameter as object data.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Make central points of control</span>. It’s a good idea to control each task in one place. Using one class to read from and write to a database is a form of centralized control.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Facilitate reusable code</span>. Code put into well-factored classes can be reused in other programs more easily than the same code embedded in one larger class.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Plan for a family of programs</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Packaging related operations</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Accomplish a specific refactoring</span>.</font></li></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Classes to avoid</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Avoid creating god classes</span><span style="font-style: italic;">. </span>Avoid creating omniscient classes that are all-powerful and constantly query other classes’ Get() and Set() routines.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Eliminate irrelevant classes</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Avoid classes named after verbs</span>. Classes that only contain behavior and no data are really routines that should be refactored into other classes.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Class-related areas that vary significantly depending on language</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Behavior of overridden constructors and destructors in an inheritance tree</font></li><li><font style="font-size: 12px;" face="Times New Roman">Behavior of constructors and destructors under exception-handling conditions</font></li><li><font style="font-size: 12px;" face="Times New Roman">Importance of default constructors</font></li><li><font style="font-size: 12px;" face="Times New Roman">Time at which a destructor is called</font></li><li><font style="font-size: 12px;" face="Times New Roman">Wisdom of overriding the language’s built-in operators, including assignment and equality</font></li><li><font style="font-size: 12px;" face="Times New Roman">How memory is handled as objects are created and destroyed or as they go out of scope</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Beyond Classes: <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Packages</span></font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Modularity can be implemented in packages, not only classes</font></li><li><font style="font-size: 12px;" face="Times New Roman">It was evident that we could better support the goals of abstraction and encapsulation if we had good tools for aggregating groups of objects.</font></li></ul></ul><div><br/></div></body></html>
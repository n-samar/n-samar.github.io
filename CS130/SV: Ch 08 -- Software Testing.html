<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-09 04:43:10 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-13 21:53:42 +0000"/><title>SV: Ch 08 -- Software Testing</title></head><body><hr/><div><font style="font-size: 12px;" face="Times New Roman"><span style="font-weight: bold;">Sommerville: Chapter 8 — Software Testing</span><br/></font></div><hr/><ul><li><font style="font-size: 12px;" face="Times New Roman">Two <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">main goals</span> of testing:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">To demonstrate to the developer and the customer that the software meets its requirements.</font></li><li><font style="font-size: 12px;" face="Times New Roman">To discover situations in which the behavior of the software is incorrect, undesirable, or does not conform to its specification.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Advantages of software inspection over testing</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">During testing, errors can mask other errors. When an error leads to unexpected outputs, you can never be sure if later output anomalies are due to a new error or are side effects of the original error. Since inspection requires developers to visually sift through source code, this is not an issue.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Incomplete versions of a system can be inspected without additional costs. If a program is incomplete, then you need to develop specialized test harnesses to test the parts that are available.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Inspection can go beyond searching for program defects. It can also consider broader quality attributes of a program, such as compliance with standards, portability, and maintainability.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">More than 60% of errors can be detected through informal code inspection.</font></li><li><font style="font-size: 12px;" face="Times New Roman">However, inspection does not replace developer testing. Inspections are not good for discovering defects that arise because of unexpected interactions between different parts of a program, timing problems, or problems with system performance.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Typically, a commercial software system needs to go through <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">3 stages of testing</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Development testing</span>, used to detect bugs and defects. System designers and programmers are likely to be involved.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Release testing</span>, where a separate testing team tests a complete version of the system before it is released to users. Aim is to check that system meets requirements.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">User testing</span>, where users of a system test the system in their own environment.</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Development Testing</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Includes all testing activities that are carried out by the team developing the system.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Development testing may be carried out at three levels of granularity:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Unit testing</span>. </font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Test all operations associated with the object</font></li><li><font style="font-size: 12px;" face="Times New Roman">Set and check the value of all attributes associated with the object</font></li><li><font style="font-size: 12px;" face="Times New Roman">Put the object into all possible states. This means all events that cause a state change should be simulated.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Automate unit testing whenever possible.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Three parts to automated test:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">A setup part, where you initialize the system with the test case, namely the inputs and expected outputs.</font></li><li><font style="font-size: 12px;" face="Times New Roman">A call part, where you call the object or method to be tested</font></li><li><font style="font-size: 12px;" face="Times New Roman">An assertion part where you compare the result of the call with the expected result.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Crucial to choose which unit tests to implement effectively</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">The test cases should show that the component that you are testing does what it is supposed to do.</font></li><li><font style="font-size: 12px;" face="Times New Roman">If there are defects in the component, these should be revealed by test cases.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">So, test for nominal and abnormal input.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">How to choose test cases</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Partition testing</span>, where you identify groups of inputs that have common characteristics and should be processed in the same way.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Guideline-based testing</span>, where you use testing guidelines to choose test cases. These guidelines reflect previous experience of the kinds of errors that programmers often make when developing components.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Testing boundary values</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Choose inputs that force the system to generate all error messages</font></li><li><font style="font-size: 12px;" face="Times New Roman">Design inputs that cause input buffers to overflow</font></li><li><font style="font-size: 12px;" face="Times New Roman">Repeat the same input or series of inputs numerous times</font></li><li><font style="font-size: 12px;" face="Times New Roman">Force invalid outputs to be generated</font></li><li><font style="font-size: 12px;" face="Times New Roman">Force computation results to be too large or too small</font></li></ul></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Component testing</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Test cases applied to interfaces between interacting components.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Types of interfaces</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Parameter interface</span>, where data is passed from one component to another.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Shared memory interfaces</span>, where a block of memory is shared between components.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Procedural interfaces</span>, where one component encapsulates a set of procedures that can be called by other components. Objects and reusable components have this kind of interface.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Message passing interfaces</span>, in which one component requests a service from another component by passing a message to it. This is implemented in some object-oriented systems and client-server systems.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Three classes of interface errors</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Interface misuse</span>. A calling component calls some other component and makes an error in the use of its interface. Includes wrong type of parameters being passed, passing parameters in wrong order, or passing a wrong number of parameters.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Interface misunderstanding</span>. A calling component misunderstands the specification of the interface of the called component and makes assumptions about its behavior. Includes calling a binary search function on an unsorted array.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Timing errors</span>. Occurs in real-time systems that use a shared memory or a message-passing interface. Includes producer and consumer operating at different speeds.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Some interface faults may manifest themselves only under very unusual conditions.</font></li><li><font style="font-size: 12px;" face="Times New Roman">General <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">guidelines for interface testing</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Examine code to be tested and explicitly list each call to an external component. Design tests in which the values of the parameters to the external component are at extreme ends of their ranges.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Where pointers are passed across an interface, always test the interface with null pointer parameters.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Where a component is called through a procedural interface, design tests that deliberately cause the component to fail. Make sure failure assumptions are well specified and understood.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Use stress testing in message passing systems. This might reveal timing issues.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Where several components interact through shared memory, design tests that vary the order in which these components are activated.</font></li></ul></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">System testing</span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">.</span></font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Checks that components are compatible, interact correctly and transfer the right data at the right time across their interfaces.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Two <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">important differences from component testing</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">During system testing, reusable components that have been separately developed or off-the-shelf systems may be integrated with newly developed components.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Components developed by different team members or groups may be integrated at this stage. System testing is a collective rather than individual process.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Emergent behavior is to be expected.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Due to the focus on intra-component interaction, use case-based testing is an effective approach to system testing.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">At the minimum</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">All system functions that are accessed through menus should be tested</font></li><li><font style="font-size: 12px;" face="Times New Roman">Combinations of functions that are accessed through the same menu must be tested.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Where user input is provided, all functions must be tested with both correct and incorrect input.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Problems often arise when combinations of less commonly used features have not been tested together. E.g. in word processors, using footnotes with a multicolumn layout causes incorrect layout of the text.</font></li></ul></ul><li><font style="font-size: 12px;" face="Times New Roman">This is primarily a defect testing process.</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Test-Driven Development (TDD)</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Never move to next code increment until the currently developed code passes all its tests.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Steps of TDD</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">You start by identifying the increment of functionality that is required. Should be small and implementable in a few lines of code.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Wrote test for this functionality and implement this as an automated test.</font></li><li><font style="font-size: 12px;" face="Times New Roman">You then run the test, along with all other tests that are already implemented.</font></li><li><font style="font-size: 12px;" face="Times New Roman">You then implement the functionality and re-run the test.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Once all tests run successfully, you move on to implementing the next chunk of functionality.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Basic idea: If you don’t have enough info to write proper test, you don’t have enough info to write the actual code.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Benefits of TDD</span> (aside from better problem understanding):</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Code coverage</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Regression testing</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Simplified debugging</span>. When a test fails, it should be obvious where the problem lies.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">System documentation</span>.</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Release testing</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">The process of testing a particular release of a system that is intended for use outside of the development team.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Distinctions between release testing and system testing</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">A separate team that has not been involved in the system development should be responsible for release testing.</font></li><li><font style="font-size: 12px;" face="Times New Roman">System testing by the development team should focus on discovering bugs in the system (<span style="text-decoration: underline;">defect testing</span>). The objective of release testing is to check that the system meets its requirements and is good enough for external use (<span style="text-decoration: underline;">validation testing</span>).</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Usually done in a black box manner.</font></li><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Requirements-based testing</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Requirements should be testable</font></li><li><font style="font-size: 12px;" face="Times New Roman">Requirements-based testing is validation rather than defect testing.</font></li></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Scenario testing</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Use use cases to elicit testing.</font></li></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Performance testing</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Usually involves tests where you increase system load until the system performance become unacceptable.</font></li><li><font style="font-size: 12px;" face="Times New Roman">This type of testing has two functions:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">It tests the failure behavior of the system. System overload is a possibility always, and system should not corrupt data or do anything terribly bad even if load is well beyond the intended limit.</font></li><li><font style="font-size: 12px;" face="Times New Roman">It stresses the system and may cause defects to come to light that would not normally be discovered.</font></li></ul></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">User testing</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Three <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">types of user testing</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Alpha testing</span>, where users of the software work with the development team to test the software at the developer’s site</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Beta testing</span>, where a release of the software is made available to users to allow them to experiment and to raise problems that they discover with the system developers.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Acceptance testing</span>, where customers test a system to decide whether or not it is ready to be accepted from the system developers and deployed in the customer environment.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">The six <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">stages of acceptance testing</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Define acceptance criteria</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Plan acceptance testing</span>. Involves deciding on the resources, time, and budget for acceptance testing and establishing a testing schedule.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Derive acceptance tests</span>. Tests have to be designed to check whether or not acceptance criteria are met.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Run acceptance tests</span>. </font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Negotiate test results</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Reject/accept systems</span>. Involves meeting between the developers and customer to decide on whether or not the system should be accepted.</font></li></ul></ul><div><br/></div></body></html>
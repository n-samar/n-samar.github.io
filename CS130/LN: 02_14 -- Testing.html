<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-09 04:35:20 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-13 21:46:48 +0000"/><title>LN: 02/14 -- Testing</title></head><body><hr/><div><font style="font-size: 12px;" face="Times New Roman"><span style="font-weight: bold;">Lecture Notes: February 14 — Testing</span><br/></font></div><hr/><ul><li><font style="font-size: 12px;" face="Times New Roman">Testing is unnatural for developers!</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">You have to hope to find bugs instead of hoping that your program works. Otherwise, you aren’t testing from the right mindset.</font></li><li><font style="font-size: 12px;" face="Times New Roman">You can’t prove your program is bug free.</font></li><li><font style="font-size: 12px;" face="Times New Roman">There’s always more test to be written, which is unsatisfying</font></li><li><font style="font-size: 12px;" face="Times New Roman">Testing by itself doesn’t improve software. Just a warning sign.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">So, developers often undervest</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Partly due to ignorance</font></li><li><font style="font-size: 12px;" face="Times New Roman">Partly due to optimism</font></li><li><font style="font-size: 12px;" face="Times New Roman">note that you can also overtest</font></li></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">What to test?</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Test your code (obviously)</font></li><li><font style="font-size: 12px;" face="Times New Roman">Test your requirements</font></li><li><font style="font-size: 12px;" face="Times New Roman">Test your design</font></li><li><font style="font-size: 12px;" face="Times New Roman">Basically, test every product of your system</font></li><li><font style="font-size: 12px;" face="Times New Roman">Test your test cases (How? Run code on them)</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Testing hooks up code, requirements, design, and test cases and makes sure they are consistent with each other.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Testing is often an inefficient way to find bugs.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Typical <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">error statistics</span> (Microsoft 2004)</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Pareto principle applies to testing: 20% of code contains 80% of the bugs</font></li><li><font style="font-size: 12px;" face="Times New Roman">Most error are local to a single routine</font></li><li><font style="font-size: 12px;" face="Times New Roman">20% of errors are simple typos</font></li><li><font style="font-size: 12px;" face="Times New Roman">20% of errors come from programers’ misunderstanding of spec</font></li><li><font style="font-size: 12px;" face="Times New Roman">1-25 errors per 1 kLOC</font></li><li><font style="font-size: 12px;" face="Times New Roman">Could get this &lt;0.001 per 1 kLOC if expensive techniques are used</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">V&amp;V - <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Verification and Validation</span></font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Verification</span> — aims at implementations:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Doest the code implement the design correctly?</font></li><li><font style="font-size: 12px;" face="Times New Roman">Are we building the product right?</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Validation</span> — aims at the requirements:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Are we building the right product?</font></li><li><font style="font-size: 12px;" face="Times New Roman">Does the design match the customer’s needs?</font></li></ul></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">System testing</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Requires the most planning</font></li><li><font style="font-size: 12px;" face="Times New Roman">Incorporate non-software components</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">recovery testing</span> for highly-available or fault-tolerant systems</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">highly-available</span>: able to recover from faults but may work with reduced availability for some time before full recovery</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">fault-tolerant</span>: if a fault happens, the user does not know about it</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">security testing</span> </font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">performance testing</span>. Performance cannot be reliably predicted.</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Instrumentation is key!</font></li></ul></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Deployment testing</span> makes sure system can be distributed to users without hiccups.</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Test distribution strategy</font></li><li><font style="font-size: 12px;" face="Times New Roman">Configuration testing</font></li></ul></ul><li><font style="font-size: 12px;" face="Times New Roman">Testing Strategy</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Test methodically. i.e., have a well-defined method for approaching the problem of testing.</font></li><li><font style="font-size: 12px;" face="Times New Roman">When your tests are successful, fix the bugs that they find.</font></li></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Terminology</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">error</span>: a mistake made by the developer</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">fault</span>: a quality problem in the software. Not every error leads to a fault (e.g. error in documentation)</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">failure</span>: misbehavior, triggered by fault, visible to user.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Testing only detects failures</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Test strategy ideas</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">Drivers</span>. Substitute for a caller</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">Stubs</span>. Substitute for callees</font></li><li><font style="font-size: 12px;" face="Times New Roman">Both stubs and drivers work at all levels of abstraction.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Bottom-up</span> vs. <span style="font-style: italic;">Top-down</span> vs. <span style="font-style: italic;">sandwich</span> testing</font></li></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Test-driven development (TDD)</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">idea: test cases first imply faster development</font></li><li><font style="font-size: 12px;" face="Times New Roman">if you find a design hard to test, maybe time to change design?</font></li><li><font style="font-size: 12px;" face="Times New Roman">you get good coverage</font></li><li><font style="font-size: 12px;" face="Times New Roman">you get regression testing</font></li><li><font style="font-size: 12px;" face="Times New Roman">makes debuggers “obsolete”. When your test case fails, it should be obvious where the mistake is.</font></li><li><font style="font-size: 12px;" face="Times New Roman">tests as documentation (reference test cases as examples)</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Issues</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">GUIs are hard to test</font></li><li><font style="font-size: 12px;" face="Times New Roman">Non-deterministic applications are hard to test</font></li><li><font style="font-size: 12px;" face="Times New Roman">does not address problem of system testing</font></li><li><font style="font-size: 12px;" face="Times New Roman">does not scale well. Only good for routine-level tests.</font></li></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Tinderboxes</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Has copy of all tests and periodically runs them</font></li><li><font style="font-size: 12px;" face="Times New Roman">Daily build as heartbeat of the project.</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Temporary, small inconsistencies are OK, but they should be fixed by next iteration</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Goal is to make tinderboxes as big as possible and still make them be practical</font></li><li><font style="font-size: 12px;" face="Times New Roman">For example, stress tests might be expensive to run daily, so usually can’t be comprehensive</font></li><li><font style="font-size: 12px;" face="Times New Roman">Don’t neglect your tinderbox. Especially if you are under pressure!</font></li><li><font style="font-size: 12px;" face="Times New Roman">In larger systems, add tests to new feature first, then test them with current software version, then add the changes to main and test again.</font></li></ul></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Test tools</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Programs that help us test better</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Test data generations</span>: off-the-shelf, but often better to be hand built</font></li><li><font style="font-size: 12px;" face="Times New Roman">Good idea to have project-specific tools. Can solve a lot of time downstream.</font></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Coverage markers</font></span></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Program logs</font></span></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Mutators</span>: deliberately introduce system changes to notice if test cases catch the error.</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">e.g. run under gcc -m34 and gcc -m64 (should run on both 34- and 64-bit systems)</font></li><li><font style="font-size: 12px;" face="Times New Roman">e.g. <span style="font-style: italic;">memory management mutator</span>: take freed data and write junk over it as soon as it is freed. This detects killed-used errors.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Bugzilla</span> — maintain a bug database to notice what is wrong with the way you do testing.</font></li></ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font style="font-size: 12px;" face="Times New Roman">Testing tactics</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Blackbox</span> vs. <span style="font-style: italic;">Whitebox</span> testing</font></li><li><font style="font-size: 12px;" face="Times New Roman">Coverage criteria — a classic white box method.</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">not enough to just excercices every line of code.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">strutted basis testing</span>: come up with methodical way to develop high confidence in system correctness — execute every arc in program control tree</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">basic set</span> = minimal set of paths that covers every node and arc in flow graph (idea is to be both economical and comprehensive)</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Equivalence partitioning</span> — a classic black box method. Look for possible inputs to module into general areas. Run the simplest, clearest test case in each equivalence class</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">test for boundary values as well!</font></li></ul></ul></ul><div><br/></div></body></html>
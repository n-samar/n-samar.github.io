<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-09 04:28:53 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-13 21:50:23 +0000"/><title>MC: Ch 24 -- Refactoring</title></head><body><div/><hr/><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">McConnel: Chapter 24 — Refactoring</font></span></div><hr/><ul><li><font face="Times New Roman" style="font-size: 12px;">Code evolves substantially during its initial development.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Coding, debugging, and unit testing consume between 30 to 65 percent of the effort on a typical project, depending on the project’s size.</font></li><li><font face="Times New Roman" style="font-size: 12px;">If you recognize that evolution during development is an inevitable and important phenomenon and plan for it, you can use it to your advantage.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Refactoring: a change made to the internal structure of the software to make it easier to understand and cheaper to modify without changing its observable behavior.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Smell signs that refactoring is needed</span>:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Code is duplicated</span>. You should never have to copy and paste.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A routine is too long</span>. A routing should fit into one screen.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A loop is too long or too deeply nested</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A class has poor cohesion</span>. If you find a class that takes ownership for a hodgepodge of unrelated responsibilities, that class should be broken up into multiple classes.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Class interface does not provide a consistent level of abstraction</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Parameter list has too many parameters</span>. Well-factored programs tend to have many small, well-defined routines that don’t need large parameter lists. A long parameter list is a warning that the abstraction of the routine interface has not been well thought out.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Changes within a class tend to be compartmentalized</span>. Sometimes a class has two or more distinct responsibilities. When that happens you find yourself changing either one part of the class or another part of the class — but few changes affect both parts of the class. That’s a sign that the class should be cleaved into multiple classes along the lines of the separate responsibilities.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Changes require parallel modifications to multiple classes</span>. Refactoring from this situation may be hard, but it is worth the effort.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Inheritance hierarchies have to be modified in parallel</span>. Finding yourself making a subclass of one class every time you make a subclass of another class is a bad sign.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Case statements have to be modified in parallel</span>. Maybe switch to inheritance?</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Related data items that are used together are not organized into classes</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A routine uses more features of another class than of its own class</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A primitive data type is overloaded</span>. If your program uses a primitive data type like an integer to represent a common entity such as money, make a Money class!</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A class doesn’t do very much</span>. If after refactoring, you figure out a class doesn’t have much to do, remove it and assign its responsibilities to the classes.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A chain of routines passes tramp data</span>. Finding yourself passing data to one routine host so that routine can pass it to another routine is called tramp data. This might be OK, but ask yourself whether passing the specific data in question is consistent with the abstraction presented by each of the routine interfaces. If the abstraction for each routine is OK, passing the data is OK.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A middleman object isn’t doing anything</span>. If you find that most of the code in a class is just passing off calls to routines in other classes, consider whether you should eliminate the middleman and call those other classes directly.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">One class is overly intimate with another</span>. Encapsulation is probably the strongest tool you have to make your program intellectually manageable and to minimize ripple effects of code changes. Err on the side of stronger encapsulation.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A routine has a poor name</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Data members are public</span>. Public data members are always a bad idea</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A subclass uses only a small percentage of its parents’ routines</span>. This typically indicates that that subclass has been created because a parent class happened to contain the routines it needed, not because the subclass is logically a descendent of the superclass. Maybe switch to containment?</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Comments are used to explain difficult code</span>. Comments should not be used as a crutch to explain bad code. Don’t document bad code, rewrite it.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Global variables are used</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A routine uses setup code before a routine call or takedown code after a routine call</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">A program contains code that seems like it might be needed someday</span>. Programmers are notoriously bad at guessing what functionality might be needed someday. Designing ahead is subject to many problems:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;">Requirements for the design ahead code haven’t been fully developed. The code ahead work will ultimately be thrown away.</font></li><li><font face="Times New Roman" style="font-size: 12px;">If the programmer’s guess about the future requirement is pretty close, the programmer still will not generally anticipate all the intricacies of the future requirements.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Future programmers who use th design ahead code don’t know that it was design ahead code, or they assume the code works better than it does.</font></li><li><font face="Times New Roman" style="font-size: 12px;">The additional design ahead code creates additional complexity, which calls for additional testing, additional defect correction, and so on. The overall effect is to slow down the project.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Best idea is to not prepare for future requirements, but to satisfy current requirements as clear and straightforward as possible so that you can make changes to it in the future.</font></li></ul></ul><li><font face="Times New Roman" style="font-size: 12px;">Note that code will essentially entropy away into a death spiral if not refactored.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">Data-Level refactoring</font></span></div><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Replace a magic number with a named constant</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Rename a variable with a clearer or more informative name</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Move an expression inline</span>. Replace an intermediate variable that was assigned the result of an expression with the expression itself.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Replace an expression with a routine</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Introduce an intermediate variable</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Convert a multiuser variable to multiple single-use variables</span>. Don’t name variables i, j, x, … They should have specific names</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Use a local variable for local purposes rather than a parameter</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Convert a data primitive to a class</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Convert a set of type codes to a class or an enumeration</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Convert a </span><span style="font-style: italic;">set of type codes to a class with subclasses</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Change an array to an object</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Encapsulate a collection</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Replace a traditional record with a data class</span>. This allows for centralized error checking, persistence, and the operations that concern the record.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">Statement-Level refactoring</font></span></div><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Decompose a boolean expression</span>. Simplify a boolean expression by introducing well-named intermediate variables that help document meaning.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Move a complex boolean expression into a well-named boolean function</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Consolidate fragments that are duplicated within different parts of a conditional</span>. </font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Use break or return instead of a loop control variable</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Return as soon as you know the answer instead of assigning a return value within </span><span style="font-style: italic;">nested if-then-else statements</span>. </font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Replace conditionals (especially repeated switch statements) with polymorphism</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Create and use null objects instead of testing for null values</span>. Consider moving the responsibility for handling null values out of the client code and into the class.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">Routine-Level refactoring</font></span></div><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Extract routine/extract method</span>. Remove inline code from one routine, and turn it into its own routine.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Move a routine’s code inline</span>. Take code from a routine whose boyd is simple and self-explanatory, and move that routine’s code inline where it is used.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Convert a long routine to a class</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Substitute a simple algorithm for a complex one</span>. </font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Add a parameter</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Remove a parameter</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Separate query operations from modification operations</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Combine similar routines by parametrizing them</span>. Two similar routines might differ only with respect to a constant value that’s used within the routine. Combine the routines into one routine.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Separate routines whose behavior depends on parameters passed in</span>. If a routine executes different code depending on the value of an input parameter, consider breaking the routine into separate routines that can be called separately, without passing in that particular input parameter.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Pass a whole object reader than specific fields</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Pass specific fields rather than a whole object</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Encapsulate </span><span style="font-style: italic;">down casting</span>. If a routine returns an object, it normally should return the most specific type of object it knows about. This is particularly applicable to routines that return iterators, collections, elements of a collection, and so on.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">Class implementation refactoring</font></span></div><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Change value objects to reference </span><span style="font-style: italic;">objects</span><span style="font-style: italic;">. </span>If you find yourself creating and maintaining numerous copies of large or complex objects, change your usage of those objects so that only one master copy exists.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Change reference objects to value objects</span>. </font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Replace virtual routines with data initialization</span>. If you have a set of subclasses that vary only according to constant values they return, rather than overriding member routines in the derived classes, have the derived classes initialize the class with appropriate constant values, and then have generic code in the base class that works with those values.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Change member routine or data placement</span>. Consider making several general changes in an inheritance hierarchy. These changes are normally performed to eliminate duplication in derived classes:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;">Pull a routine up into its superclass</font></li><li><font face="Times New Roman" style="font-size: 12px;">Pull a field up into its superclass</font></li><li><font face="Times New Roman" style="font-size: 12px;">Pull a constructor body up into its superclass</font></li><li><font face="Times New Roman" style="font-size: 12px;">Push a routine down into its derived classes</font></li><li><font face="Times New Roman" style="font-size: 12px;">Push a field down into its derived classes</font></li><li><font face="Times New Roman" style="font-size: 12px;">Push a constructor body down into its derived classes</font></li></ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Extract specialized code into a subclass</span>. </font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Combine similar code into a superclass</span>. </font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">Class interface refactoring</font></span></div><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Move a routine to another class</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Convert one class to two</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Eliminate a class</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Hide a delegate</span>. Sometimes class A calls class B and class C, when really class A should call only class B and class B should call class C.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Remove a middleman</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Replace inheritance with delegation</span>. If a class needs to use another class but wants more control over its interface, make the superclass a field of the former subclass and then expose a set of routines that will provide a cohesive abstraction.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Replace delegation with </span><span style="font-style: italic;">inheritance</span>. If a class exposes every public routine of a delegate class (member class), inherit from the delegate class instead of just using the class.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Introduce a foreign routine</span>. If a class needs an additional routine and you can’t modify the class to provide it, you can create a new routine within the client class that provides that functionality.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Introduce an extension class</span>. If a class needs several additional routines and you can’t modify the class, you can create a new class that combines the unmodifiable class’s functionality with the additional functionality. This can be done through subclassing the original class and adding new routines or by wrapping the class and exposing the routines you need.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Encapsulate an exposed member variable</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Remove the set() routines for fields that cannot be changed</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Hide routines that are not intended to be used outside the class</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Encapsulate unused routines</span>. If you find yourself routinely using only a portion of a class’s interface, create a new interface to the class that exposes only those necessary routines. Be sure that the new interface provides a coherent abstraction.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Collapse a superclass and subclass if their implementations are very similar</span>.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">System-Level refactoring</font></span></div><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Create a definitive reference source for data you can’t control</span>. Sometimes you have data maintained by the system that you can’t conveniently or consistently access from other objects that need to know about that data.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Change unidirectional class association to bidirectional association</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Change bidirectional </span><span style="font-style: italic;">class association to unidirectional class association</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Provide a factory method rather than a simple constructor</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Replace error codes with exceptions and vis versa</span>.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">Refactoring safely</font></span></div><ul><li><font face="Times New Roman" style="font-size: 12px;">Refactoring can cause more harm than good if misused.</font></li><li><font face="Times New Roman" style="font-size: 12px;">A few simple <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">refactoring safely guidelines</span>:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Save the code you start with</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Keep refactoring small</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Do refactoring one at a time</span>. Recompile and retest after each refactoring.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Make a list of steps you intend to take</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Make a parking lot</span>. While you are doing a refactoring, you will probably realize that other code can also be refactored. Keep these new refactoring ideas in a list, but don’t address them immediately if not completely necessary.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Make frequent checkpoints</span>. Checkpoints constitute points in your refactoring process where you actually have saved, runnable code.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Use your compiler warnings</span>. Set your compiler to the pickiest options possible.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Retest</span>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Add test cases</span>. In order to exercise the new code.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Review the changes</span>. If reviews are important the first time through, they are even more important during subsequent modifications. There is more than a 50% chance you will not make a desired change properly. Interestingly, the more lines of code need to be changed in the refactoring, the lower the chance of errors.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Adjust your approach depending on the risk level of the refactoring</span>. Have someone else review risky refactoring or use pair programming in addition to regular compiler checks and unit tests.</font></li></ul></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><ul><li><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"><font face="Times New Roman" style="font-size: 12px;">Bad times to refactor</font></span></li><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Don’t use refactoring as a cover for code and fix</span>. Programmers will sometimes say they’re refactoring, when all they’re really doing is tweaking the code, hoping to find a way to make it work. Refactoring refers to changes in working code that do not affect the program’s behavior.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Avoid refactoring instead of </span><span style="font-style: italic;">rewriting</span>. Sometimes code doesn’t need small changes — it needs to be tossed out so that you can start over. If you find yourself in a major refactoring session, ask yourself whether instead you should be redesigning and reimplementing that section of code from the ground up.</font></li></ul></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">Refactoring strategies</font></span></div><ul><li><font face="Times New Roman" style="font-size: 12px;">Spend your time on the 20 percent of the refactoring that provide 80% of the benefit. Consider the following <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">guidelines when deciding </span><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">which refactorings are most important</span>:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Refactor when you add a routine</span>. When you add a routine, check whether related routines are well organized. If not, refactor them.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Refactor when you add a class</span>. Adding a class often brings up issues with existing code to the fore.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Refactor when you fix a defect</span>. Use the understanding you gain from fixing a bug to improve other code that might be prone to similar defects.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Target error-prone modules</span>. Is there a section of code that you and everyone else on your team is afraid of? Fix that!</font></li><li><font face="Times New Roman" style="font-size: 12px;"> <span style="font-style: italic;">Target high-complexity modules</span>. Target modules with high complexity ratings (Section 19.6). This is a proven strategy.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">In a maintenance environment, improve the parts you touch</span>. Make sure you leave each bit of code you touch better than you found it.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-style: italic;">Define an interface between clean code and ugly code, and then move code across the interface</span>. If the system must keep working throughout refactoring, this is a particularly powerful strategy.</font></li></ul></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><ul><li><font face="Times New Roman" style="font-size: 12px;"><span style="font-weight: bold;">The Cardinal Rule of Software Evolution</span>: internal quality should improve with code evolution.</font></li></ul><div><br/></div></body></html>
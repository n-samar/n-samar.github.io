<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-09 04:27:24 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-13 21:50:39 +0000"/><title>MC: Ch 25 -- Code Tuning Strategies</title></head><body><hr/><div><font style="font-size: 12px;" face="Times New Roman"><span style="font-weight: bold;">McConnel: Chapter 25 — Code-Tuning Strategies</span><br/></font></div><hr/><ul><li><font style="font-size: 12px;" face="Times New Roman">Code running is one way of improving a program’s performance. </font></li><li><font style="font-size: 12px;" face="Times New Roman">You can often find other ways to improve performance more — and in less time and with less harm to the code — than by code running.</font></li><li><font style="font-size: 12px;" face="Times New Roman">More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason — including blind stupidity.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Users are only interested in performance if it affects their work.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Users tend to be more interested in programming throughput than performance. Delivering software on time, providing a clean user interface, and avoiding downtime are often more significant.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Performance is only loosely related to code speed. Be wary of sacrificing other characteristics to make your code faster.</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Efficiency from different viewpoints</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Program requirements</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Performance is stated as a requirement far more often than it is actually required.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Before you invest time solving a performance problem, make sure you’re solving a problem that needs to be solved.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Program design</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Some program designs make it difficult to write a high-performance system. Others make it hard not to.</font></li><li><font style="font-size: 12px;" face="Times New Roman">If performance is a major requirement, design a performance-oriented architecture, and then set resource goals for individual subsystems, features, and classes. This helps in several ways:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Setting individual resource goals makes the system’s ultimate performance predictable. You can identify subsystems that have trouble meeting their goals early and target them for redesign or code tuning.</font></li><li><font style="font-size: 12px;" face="Times New Roman">The mere act of making goals explicit improves the likelihood that they’ll be achieved. he more explicit the objectives, the easier they are to work to.</font></li><li><font style="font-size: 12px;" face="Times New Roman">You can set goals that don’t achieve efficiency directly but promote efficiency in the long run. For example, employing a highly modular design is a good choice if you are not sure how stringent and where the performance requirements will apply. The slower modules can later by swapped for faster ones.</font></li></ul></ul><li><font style="font-size: 12px;" face="Times New Roman">Class and routine design</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Choice of data types and algorithms for performance (e.g. quicksort instead of bubblesort)</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Operating-system interactions</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">If performance is not good, it might be because the operating-system routines are slow.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Code compilation</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">If you choose the right compiler, you might not need to think about optimizing speed any further.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Hardware</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Sometimes the cheapest and best way to improve a program’s performance is to buy new hardware.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Code tuning</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Code tuning is the practice of modifying correct code in ways that make it run more efficiently. </font></li><li><font style="font-size: 12px;" face="Times New Roman">Tuning does not refer to large-scale design changes or other higher-level means of improving performance.</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Code Tuning</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">It is not the most effective way to improve performance</font></li><li><font style="font-size: 12px;" face="Times New Roman">Efficient code isn’t necessarily better code.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Pareto principle applies: Less than 4% of a program accounts for half of the runtime.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Due to pareto principle, you can write your application in python first, and then optimize bottlenecks in C.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Rules of the performance game change every time you change or upgrade the compiler, language, versions of compilers, libraries, versions of libraries, processor, amount of memory in the machine.</font></li><li><font style="font-size: 12px;" face="Times New Roman">If you need a portable system, techniques that improve performance in one environment can degrade it in others.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Never optimize as you go. That is, premature optimization is bad. Focusing on just routine-level optimization loses the forest for the trees. Here are the main <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">issues with optimizing as you go</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">It’s almost impossible to identify performance bottlenecks before a program is working completely. This implies you will spend a lot of time optimizing irrelevant parts of the code.</font></li><li><font style="font-size: 12px;" face="Times New Roman">In the rare case in which developers identify the bottlenecks correctly, they overkill the bottlenecks they’ve identified and allow others to become critical.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Focusing on optimization during initial development detracts from achieving other program objectives.</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><ul><li><font style="font-size: 12px;" face="Times New Roman">When your program is correct and complete, check the performance. Don’t optimize until you know you need to.</font></li><li><font style="font-size: 12px;" face="Times New Roman">To pick a compiler, cross check performance results with different compilers on your program.</font></li><li><font style="font-size: 12px;" face="Times New Roman">If you do clever things like fooling around with loop indexes, your compiler has a harder time doing its job and your program suffers.</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Common Sources of Inefficiency</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">Input/output operations</span>. One of the most significant sources of inefficiency is unnecessary input/output. Use in-memory data structures instead of going back to storage every time unless space is critical.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">Paging</span>. An operation that causes the operating system to swap pages of memory is much slower than an operation that works on only one page of memory.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">System calls</span>. Calls to system routines are often expensive. They involve context switching. To avoid them you can employ the following approaches:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Write your own services. This is great in case your needs are only a subset of the actual functionality you need.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Avoid going to the system.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Work with the system vendor to make the call faster.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">Interpreted languages</span>.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic; text-decoration: underline;">Errors</span>. Errors can include leaving debugging code turned on (such as logging trace information to a file), forgetting to deallocate memory, improperly designing database tables, polling nonexistent devices until they time out, …</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Measurement</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Many aspects of performance are counterintuitive. So, you have to measure.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Experience doesn’t help much either, because performance depends on so many factors that change project to project.</font></li><li><font style="font-size: 12px;" face="Times New Roman">You have to measure before improving performance AND after you make the changes in order to verify that the gain in performance is worth the lack of clarity.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Your <span style="font-weight: bold;">measurements</span> <span style="font-weight: bold;">need to be precise</span>. Make sure you are measuring the right thing in the right way. </font></li><li><font style="font-size: 12px;" face="Times New Roman">Use the number of CPU clock ticks allocated to your program rather than the time of day.</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Improve code iteratively, layering performance improving techniques until you get the results you need.</font></li></ul><div><br/></div></body></html>
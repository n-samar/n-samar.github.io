<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-09 04:41:21 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-13 21:52:28 +0000"/><title>SV: Ch 02 -- Software Processes</title></head><body><div/><hr/><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Somerville: Chapter 2 — Software processes</font></span></div><hr/><ul><li><font style="font-size: 12px;" face="Times New Roman">A software process is a set of related activities that leads to the production of a software product</font></li><li><font style="font-size: 12px;" face="Times New Roman">The four fundamental steps to software engineering</font></li><ul><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Software specification</font></span></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Software design and implementation</font></span></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Software validation</font></span></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Software evolution</font></span></li></ul><li><font style="font-size: 12px;" face="Times New Roman">All four are part of software processes</font></li><li><span style="color: rgb(35, 31, 32);"><font style="font-size: 12px;" face="Times New Roman">Software processes can be improved by process standardization where the diver- sity in software processes across an organization is reduced. This leads to improved communication and a reduction in training time, and makes automated process sup- port more economical.</font></span></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); color: rgb(35, 31, 32); font-style: italic;-evernote-highlight:true;">Process models</span><span style="color: rgb(35, 31, 32);"> (abstracted representations of software processes):</span></font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="color: rgb(35, 31, 32); font-style: italic;">The waterfall model</span><span style="color: rgb(35, 31, 32);">. Represents the fundamental process activities as separate process phases.</span></font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><img src="SV%3A%20Ch%2002%20--%20Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%201.09.25%20PM.png" height="300" width="534"/><br/></font></div><ul><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Incremental development. </span>This approach interleaves the activities of specification, development, and validation. The system is developed in a series of versions.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Reuse-oriented software engineering.</span> Based on the existence of a significant number of reusable components. The system development process focuses on integrating these components into a system rather than developing them from scratch.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Parts of the system which are difficult to specify in advance, such as the user interface, should always be developed using an incremental approach</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">The Waterfall Model</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">A plan-driven process — you must, in principle, plan and schedule all of the process activities before starting work on them.</font></li><li><font style="font-size: 12px;" face="Times New Roman">The principle stages of the waterfall model directly reflect the fundamental development activities:</font></li><ul><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Requirements analysis and definition. </font></span></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">System and software design. </span>Allocates the requirements to either hardware or software systems by establishing an overall system architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships.</font></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Implementation and unit testing. </font></span></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Integration and system testing.</font></span></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Operation and maintenance.</font></span></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Incremental Development</font></span></div><div><font style="font-size: 12px;" face="Times New Roman"><img src="SV%3A%20Ch%2002%20--%20Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%202.11.26%20PM.png" height="266" width="490"/><br/></font></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Better than the waterfall model for most business, e-commerce, and personal systems.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Benefits compared to waterfall model:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">The cost of accommodating changing customer requirements is reduced.</font></li><li><font style="font-size: 12px;" face="Times New Roman">It is easier to get customer feedback on the development work that has been done.</font></li><li><font style="font-size: 12px;" face="Times New Roman">More rapid delivery and deployment of useful software to the customer is possible.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Incremental development can be</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Plan-driven</span>: the system increments are identified in advance</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Agile</span>: the early increments are identified but the development of later increments depends on progress and customer priorities.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">From a management perspective the incremental approach has two problems</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">The process is not visible. Managers need regular deliverables to measure progress.</font></li><li><font style="font-size: 12px;" face="Times New Roman">System structure tends to degrade as new increments are added. Unless time and money is spent on refactoring to improve the software, regular change tends to corrupt its structure. Incorporating further software changes becomes increasingly difficult and costly.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">These issues are particularly pronounced for large, complex, long-lifetime systems, where different teams develop different parts of the system. Large systems need a stable framework or architecture and the responsibilities of the different teams working on parts of the system need to be clearly defined with respect to that architecture.</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Reuse-oriented software engineering</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Reuse-oriented approaches rely on a large base of reusable software components and an integrating framework for the composition of these components.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Stages of reuse-oriented software engineering are:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Component analysis. </span>Given the requirements specification, a search is made for components to implement that specification</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Requirements modification. </span>The requirements are modified based on information about the components that have been discovered.</font></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">System design with reuse</font></span></li><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Development and integration</font></span></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Requirements Engineering</font></span></div><div><font style="font-size: 12px;" face="Times New Roman"><img src="SV%3A%20Ch%2002%20--%20Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%204.57.32%20PM.png" height="275" width="533"/><br/></font></div><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Software design and implementation</font></span></div><div><font style="font-size: 12px;" face="Times New Roman"><img src="SV%3A%20Ch%2002%20--%20Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%204.58.54%20PM.png" height="367" width="474"/><br/></font></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Four activities that may be part of the <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">design process for information systems</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Architectural design. </span>Identify the overall structure of the system.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Interface design. </span>Identify the interfaces between system components.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Component design.</span> Design how each system component will operate, including specific functional requirements for each component.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Database design.</span> Design the system data structures and how these are to be represented in a database</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Software validation</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Software verification and validation is intended to show that a system both conforms to its specification and that it meets the expectations of the system customer</font></li><li><font style="font-size: 12px;" face="Times New Roman">The<span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;"> stages in the testing process</span> are</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Development testing. </span>The components making up the system are tested by the people developing the system.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">System testing. </span>This process is concerned with finding errors that result from unanticipated interactions between components and component interface problems.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Acceptance testing.</span> The system is tested with data supplied by the system customer rather than with simulated test data.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Beta testing </span>is another option. Here, the beta customer are given a product to play with and test, while reporting errors and bugs.</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Coping with change</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">It is essential that whatever software process model is used it can accommodate changes to the software being developed.</font></li><li><font style="font-size: 12px;" face="Times New Roman">There are two related approaches that may be used to <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">reduce the costs of rework</span></font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Change avoidance</span>, where the software process includes activities that can anticipate possible changes before significant rework is required. Prototyping can be a good tool for anticipating changing requirements since it can be used by stakeholders prior to serious development.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Change tolerance</span>, where the process is designed so that changes can be accommodated at relatively low cost. Usually involves some type of incremental development.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Refactoring</span>, improving the structure and organization of a program, is also an important mechanism that supports change tolerance.</font></li></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Prototyping</font></span></div><div><font style="font-size: 12px;" face="Times New Roman"><img src="SV%3A%20Ch%2002%20--%20Software%20Processes.resources/Screen%20Shot%202018-01-23%20at%205.24.37%20PM.png" height="165" width="545"/><br/></font></div><ul><li><font style="font-size: 12px;" face="Times New Roman">During requirements engineering, a prototype can help with the elicitation and validation of system requirements.</font></li><li><font style="font-size: 12px;" face="Times New Roman">In the system design process, a prototype can be used to explore particular software solutions and to support user interface design.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Rapid prototyping with end-user involvement is the only sensible way to develop graphical user interfaces for software systems.</font></li><li><font style="font-size: 12px;" face="Times New Roman">To reduce costs, prototyping can be done with relaxed non-functional requirements, reduced functionality, and no or little error-handling</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Issues</span> that might arise with prototyping:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">It may be impossible to tune the prototype to meet non-functional requirements</font></li><li><font style="font-size: 12px;" face="Times New Roman">Rapid change during development means that the prototype is probably undocumented, which is not good enough for long-term maintenance.</font></li><li><font style="font-size: 12px;" face="Times New Roman">The system structure may get compromised in order to conform to prototype</font></li><li><font style="font-size: 12px;" face="Times New Roman">Organizational quality standards are normally relaxed for prototype development.</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Incremental delivery</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Each increment provides a part of the system’s functionality and is fully deployed to the user by the end of its cycle. Usually, the highest priority functionalities are delivered first.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Advantages</span> of incremental delivery include:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Customers can use the early increments as prototypes and gain experience that informs their requirements for later system increments.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Customers do not have to wait for entire system to derive value from using it</font></li><li><font style="font-size: 12px;" face="Times New Roman">The process is developed with the mindset of adding new functionality being easy</font></li><li><font style="font-size: 12px;" face="Times New Roman">Since the highest priority tasks are delivered first, the most importance services get the most user testing</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Issues</span> with incremental delivery:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">It can be hard to identify common facilities that are needed by all increments.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Iterative development does not generally give useful feedback if it is done on systems that are developed to replace older systems.</font></li><li><font style="font-size: 12px;" face="Times New Roman">In the incremental approach, there is no complete system specification until the final increment is specified. This might be hard for large contractors, like the government, to accommodate.</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">Bohm’s spiral model</font></span></div><div><font style="font-size: 12px;" face="Times New Roman"><img src="SV%3A%20Ch%2002%20--%20Software%20Processes.resources/600px-Spiral_model_(Boehm,_1988).svg.png" height="500" width="600"/><br/></font></div><ul><li><font style="font-size: 12px;" face="Times New Roman">A risk-driven software process framework.</font></li><li><font style="font-size: 12px;" face="Times New Roman">Each loop in the spiral is split into four sectors:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Objective setting. </span>Objectives for current phase of project are defined. Project risks are identified. Alternative strategies, based on these risks, may be planned.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Risk assessment and reduction. </span>For each of the identified risks, a detailed analysis is carried out. Steps are taken to reduce the risk.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Development and validation.</span> After risk evaluation, a development model for the system is chosen.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Planning. </span>The project is reviewed and a decision made whether to continue with a further loop of the spiral.</font></li></ul></ul><div><font style="font-size: 12px;" face="Times New Roman"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12px;" face="Times New Roman">The Rational Unified Process (RUP)</font></span></div><ul><li><font style="font-size: 12px;" face="Times New Roman">Described from <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">3 perspectives</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">A dynamic perspective</span>, which shows the phases of the model over time</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">A static perspective</span>, which shows the process activities that are enacted</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">A practice perspective</span>, which suggests general good practices to be used during the process</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Four <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">phases of RUP</span>:</font></li><ul><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Inception</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Establish a business case for the system </font></li><li><font style="font-size: 12px;" face="Times New Roman">Define stakeholders and define how they interact with the system</font></li><li><font style="font-size: 12px;" face="Times New Roman">Assess what contribution the system makes to the business</font></li></ul><li><span style="font-style: italic;"><font style="font-size: 12px;" face="Times New Roman">Elaboration</font></span></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Develop an understanding of the problem domain</font></li><li><font style="font-size: 12px;" face="Times New Roman">Establish architectural framework for the system</font></li><li><font style="font-size: 12px;" face="Times New Roman">Identify key project risk</font></li><li><font style="font-size: 12px;" face="Times New Roman">Develop project plan</font></li><li><font style="font-size: 12px;" face="Times New Roman">On completion, you should have a requirements model for the system, an architectural description, and a development plan</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Construction. </span>The construction phase involves system design, programming, and testing. On completion, you should have a working software system and associated documentation that is ready for delivery to users.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Transition. </span>Moving the system from the development community to the user community and making it work in a real environment. Sometimes expensive and problematic. On completion, you should have a documented software system that is working correctly in its operational environment.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Six <span style="background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">fundamental software engineering best practices</span>:</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Develop software interatively. </span>Plan increments based on customer priorities.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Manage requirements. </span>Explicitly document the customer’s requirements and keep track of changes to these requirements. Analyze the impact of changes on the system before accepting them.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Use component-based architectures. </span>Structure the system architecture into independent components.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Visually model software. </span>Use graphical models to present static and dynamic views of the software.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Verify software quality. </span>Ensure that the software meets the organization quality standards.</font></li><li><font style="font-size: 12px;" face="Times New Roman"><span style="font-style: italic;">Control changes to software. </span>Manage changes to the software using a change management system and configuration management procedures and tools.</font></li></ul><li><font style="font-size: 12px;" face="Times New Roman">Embedded software development is not ideal for using RUP.</font></li><li><font style="font-size: 12px;" face="Times New Roman">RUP separates phases of development and workflows</font></li><ul><li><font style="font-size: 12px;" face="Times New Roman">Phases are dynamic and have goals</font></li><li><font style="font-size: 12px;" face="Times New Roman">Workflows are static and are technical activities that are not associated with a single phase but may be used throughout the development to achieve the goals of each phase.</font></li></ul></ul><div><br/></div></body></html>
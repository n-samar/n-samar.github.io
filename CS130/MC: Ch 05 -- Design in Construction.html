<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-09 04:50:43 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-13 21:49:21 +0000"/><title>MC: Ch 05 -- Design in Construction</title></head><body><hr/><div><font face="Times New Roman"><span style="font-size: 12px; font-weight: bold;">McConnell: Chapter 5 — Design in Construction</span><br/></font></div><hr/><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Design is the activity that links requirements to coding and debugging</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Software engineering in the real is a problem that can only be specified once the whole or part of the solution is implemented.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Design process is characterized by many dead-allies you encounter on the road to specifying a functional design</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Making mistakes is the point of design; a good solution is often only subtly different from a poor one</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Design is about tradeoffs and priorities</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Design involves specifying restrictions required to effectively solve a problem given the resources available</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Design provides a heuristic</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Design is emergent</font></span></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Key design concepts</font></span></div><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Software’s primary technical imperative is managing complexity. Read “No Silver Bullets: Essence and Accidents of Software Engineering”</font></span></li><li><font face="Times New Roman"><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Importance of managing complexity</span><span style="font-size: 12px;">:</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">When projects fail for reasons that are primarily technical, the reason is often uncontrolled complexity.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Managing complexity is the most important technical topic  in software development</font></span></li></ul><li><span style="font-size: 12px;"><font face="Times New Roman">Due to the unmanageable amount of complexity in each program, we as software developers shouldn’t try to cram whole programs in our brains at once; instead we should organize the programs in such a way that we can safely focus on one part of it at a time.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">The goal is to minimize the amount of a program you have to think about at any one time.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Carefully defined objects separate concerns so that you can focus on one thing at a time.</font></span></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">How to Attack Complexity</font></span></div><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Causes of overly costly, ineffective designs:</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">A complex solution to a simple problem</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">A simple, incorrect solution to a complex problem</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">An inappropriate, complex solution to a complex problem</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px;">Two approaches to </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">managing complexity</span><span style="font-size: 12px;">:</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Minimize the amount of essential complexity that anyone’s brain has to deal with at any one time</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Keep accidental complexity from needlessly proliferating</font></span></li></ul><li><span style="font-size: 12px;"><font face="Times New Roman">Once you understand that all other technical goals in software are secondary to managing complexity, many design considerations become straightforward</font></span></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Desirable Characteristics of a Design</font></span></div><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Minimal complexity</span><span style="font-size: 12px;">. The primary goal of design should be to minimize complexity. Simple and easy-to-understand is more important than clever.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Ease of maintenance</span><span style="font-size: 12px;">. Think of the maintenance programmer as your audience.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Loose coupling</span><span style="font-size: 12px;">. Hold connections among different parts of a program to a minimum.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Extensibility</span><span style="font-size: 12px;">. Extensibility means that you can enhance a system without affecting other pieces.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Reusability</span><span style="font-size: 12px;">. </span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">High fan-in</span><span style="font-size: 12px;">. Refers to having a high number of classes that use a given class. High fan-in implies that a system has been designed to make good use of utility classes at the lower levels in the system.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Low-to-medium fan-out</span><span style="font-size: 12px;">. Have any given class use a low-to-medium number of other classes.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Portability</span><span style="font-size: 12px;">.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Leanness</span><span style="font-size: 12px;">. Design system so that it has no extra parts.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Stratification</span><span style="font-size: 12px;">. Software layering.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Standard techniques</span><span style="font-size: 12px;">. Use standardized and common approaches to your design so that they can be easily explained to other developers.</span></font></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Levels of Design</font></span></div><ul><li><font face="Times New Roman"><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Levels at which design should be described</span><span style="font-size: 12px;"> include:</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Software system level</font></span></li><li><font face="Times New Roman"><span style="font-size: 12px;">Division into subsystems/packages. Be sure to explicitly restrict communication between subsystems. Without any restriction, each subsystem will end up talking to each other subsystem and it would all grow into a big mess. There better be a good reason for initiating communication between two subsystems. Easier to restrict communication early and relax it later. </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Why restricting communication is important</span><span style="font-size: 12px;">:</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">How many different parts of the system does a developer need to understand at least a little bit to change something in the graphics subsystem?</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">What happens if you try to use the business rules in another system?</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">What happens when you want to put a new UI on the system, perhaps a command-line UI for testing?</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">What happens when you want to put data storage on a remote machine?</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">The communication graph between subsystems should be an Acyclic Graph</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">The simplest communication connection is having one subsystem call routines from another</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">A more involved relationship is to have one subsystem contain classes from another</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">The most involved relationship is to have classes in one subsystem inherit from classes in another.</font></span></li></ul><li><span style="font-size: 12px;"><font face="Times New Roman">Division into classes within packages</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Division into data and routines within classes</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Internal routine design</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Commonly encountered subsystems</span><span style="font-size: 12px;">:</span></font></li><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Business rules</span><span style="font-size: 12px;">. These are the laws, regulations, policies, and procedures that you encode into a computer system.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">User interface</span><span style="font-size: 12px;">. Create a subsystem to isolate user-interface components so that the user interface can evolve without damaging the rest of the program.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Database access</span><span style="font-size: 12px;">. You should hide the implementation details of accessing a database so that most of the program doesn’t need to worry about the messy details of manipulating low-level structures and can deal with the data in terms of how it’s used at the business-problem level.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">System dependencies</span><span style="font-size: 12px;">. Package operating-system dependencies into a subsystem for the same reason you package hardware dependencies.</span></font></li></ul><li><span style="font-size: 12px;"><font face="Times New Roman">The major design activity at the level of division into classes is to make sure that all the subsystems have been decomposed to a level of detail fine enough that you can implement their parts as individual classes.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">The internal routine design is always done by necessity, though sometimes it’s done unconsciously and poorly rather than consciously and well.</font></span></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Design Building Blocks: Heuristics</font></span></div><ul><li><span style="font-size: 12px;"><font face="Times New Roman">The primary purpose of the following heuristics is to help manage complexity</font></span></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Find Real-World Objects</span><span style="font-size: 12px;">.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Identify the objects and their attributes</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Determine what can be done to each object</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Determine what each object is allowed to do to other objects</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Determine the parts of each object that will be visible to other objects</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Define each object’s public interface</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px;">Possible </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">barriers to information hiding</span><span style="font-size: 12px;">:</span></font></li><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Excessive distribution of information</span><span style="font-size: 12px;">. Centralized information makes information hiding a lot easier.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Circular dependencies</span><span style="font-size: 12px;">. As when a routine in class A calls a routine in class B, and a routine in class B calls a routine in class A. These also make a system hard to test because you can’t test either A or B until at least part of the other is ready.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Class data mistaken for global data</span><span style="font-size: 12px;">. While the road to programming hell is paved with global variables, class data presents far fewer risks. Two problems of global data:</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Routines operate on global data without knowing that other routines are operating on it</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Routines are aware that other routines are operating on the global data but they don’t know exactly what they’re doing to it.</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Perceived performance penalties</span><span style="font-size: 12px;">.The concern is that accessing data items indirectly incurs run-time performance penalties for additional levels of object intentions, routine class, and so on. However, at the point of design, this concern is premature. Until you can measure system performance and pinpoint specific bottlenecks, the best way to prepare for code-level performance work is to create a highly modular design.</span></font></li></ul></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Value of Information Hiding</font></span></div><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Information hiding is one of the few theoretical techniques that has indisputably proven its value in practice.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Information hiding is part of the foundation of both structured design and object-oriented design.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Information hiding inspires and promotes design devisions that thinking about objects does not.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Asking about what needs to be hidden supports good design decisions at all levels</font></span></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Identify Areas Likely to Change</font></span></div><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Accommodating changes is one of the most challenging aspects of good program design</font></span></li><li><font face="Times New Roman"><span style="font-size: 12px;">The goal is to </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">isolate unstable areas</span><span style="font-size: 12px;"> so that the effect of a change will be limited to one routine, class or package.</span></font></li><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Identify items that seem likely to change</span><span style="font-size: 12px;">. If the requirements are done well, this step should be straightforward.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Separate items that are likely to change</span><span style="font-size: 12px;">. Compartmentalize each volatile component identified in step 1.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Isolate items that seem likely to change</span><span style="font-size: 12px;">. Design the interclass interfaces to be insensitive to the potential changes.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Business rules</span><span style="font-size: 12px;">. Business rules tend to be the source of frequent software changes.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Hardware dependencies</span><span style="font-size: 12px;">. Important for moving the program to a new environment.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Input and output</span><span style="font-size: 12px;">. Input/output tends to be a volatile area. In general, it is good to examine all external interfaces for possible changes.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Nonstandard language features</span><span style="font-size: 12px;">.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Difficult design and construction areas</span><span style="font-size: 12px;">. It’s a good idea to hide difficult design and construction areas because they might be done poorly and you might need to do them again.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Status variables</span><span style="font-size: 12px;">. Status variables indicate the state of a program and tend to be changed more frequently. Adding flexibility to status variables includes:</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Don’t use a boolean variable as a status variable. Use an enumerated type so that you can add more sophisticated state detection later.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Use access routines rather than checking the variables directly. This also allows for more sophisticated state detection.</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Data size constraints</span><span style="font-size: 12px;">. When you declare an array of size 100, you’re exposing information to the world that the world doesn’t need to see. Use a layer of indirection by declaring a constant like MAX_EMPLOYEES and set it to 100.</span></font></li></ul></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Anticipating Different Degrees of Change</font></span></div><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Only extremely unlikely changes should be allowed to have drastic consequences for more than one class in a system.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Consider qualitative changes as well: making the program thread-safe, making it localizable, …</font></span></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Keep Coupling Loose</font></span></div><ul><li><font face="Times New Roman"><span style="font-size: 12px;">Here are several criteria to use in </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">evaluating coupling between modules</span></font></li><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Size</span><span style="font-size: 12px;">. Refers to the number of connections between modules.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Visibility</span><span style="font-size: 12px;">. Visibility referes to the prominence of the connection between two modules. If connections must exist they should be salient and obvious.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Flexibility</span><span style="font-size: 12px;">. Refers to how easily you can change the connections between modules. The more easily other modules can call a module, the more loosely coupled it is, and that’s good because it’s more maintainable and flexible.</span></font></li></ul><li><font face="Times New Roman"><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Kinds of coupling</span><span style="font-size: 12px;">:</span></font></li><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Simple data-parameter coupling</span><span style="font-size: 12px;">. Two modules are coupled in this way if all parameters passed between them are of primitive type and all data is passed by means of parameter lists. This kind of coupling is normal and acceptable.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Simple object coupling</span><span style="font-size: 12px;">.A module is simple-object coupled to an object if it instantiates that object. This kind of coupling is OK.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Object-parameter coupling</span><span style="font-size: 12px;">. Two objects are object-parameter coupled if Object1 requires Object2 to pass it Object3. This is tighter than having Object2 just pass primitive data types because it requires Object2 to know about Object3.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Semantic coupling</span><span style="font-size: 12px;">. One module makes use not of some syntactic element of another module but of some semantic knowledge of the other module’s inner workings.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Dangerous because changing code in the used module changes behavior of the using module indirectly, which makes debugging very hard.</font></span></li></ul></ul><li><span style="font-size: 12px;"><font face="Times New Roman">Classes and routines are first and foremost intellectual tools for reducing complexity. If they’re not making your life simpler they’re not doing their job.</font></span></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Look for Common Design Patterns</font></span></div><ul><li><font face="Times New Roman"><span style="font-size: 12px;">The book </span><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Design Patterns (1995) is the definitive description of design patterns.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Benefits of pattern designs</span><span style="font-size: 12px;"> that fully custom design doesn’t have:</span></font></li><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Patterns reduce complexity by providing ready-made abstractions</span><span style="font-size: 12px;">. Programmers will understand better what you mean when you implement your solutions through well known patterns.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Patterns reduce errors by institutionalizing details of common solutions</span><span style="font-size: 12px;">. Patterns embody the wisdom accumulated from years of attempting to solve those problems, and they also embody the corrections to the false attempts that people have made in solving those problems. Using design patterns is this conceptually similar to using library code instead of writing your own.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Patterns provide heuristic value by suggesting design alternatives</span><span style="font-size: 12px;">. A designer who is familiar with common patterns can easily run through a list of patterns and ask “Which of these patterns fits my design problem?”</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic;">Patterns streamline communication by moving the design dialog to a higher level</span><span style="font-size: 12px;">.The vocabulary of a specific pattern helps developers communicate between each other.</span></font></li></ul><li><span style="font-size: 12px;"><font face="Times New Roman">Assigning specific names and concepts to already known design patterns is a valuable tool in itself.</font></span></li><li><font face="Times New Roman"><span style="font-size: 12px;">A </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">possible trap of using patterns</span><span style="font-size: 12px;">:</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Forcing a solution to fit a pattern when it can’t</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Using patterns just to try them out rather than picking an appropriate one</font></span></li></ul></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Other Heuristics</font></span></div><ul><li><span style="font-size: 12px; font-style: italic; text-decoration: underline;"><font face="Times New Roman">Aim for strong cohesion.</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Cohesion refers to how closely all the routines in a class or all the code in a routine support a central purpose</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Important because the more that code in a class supports a central purpose, the more easily your brain can remember everything the code does.</font></span></li></ul><li><span style="font-size: 12px; font-style: italic; text-decoration: underline;"><font face="Times New Roman">Build hierarchies of abstraction</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Hierarchies were an important tool for managing complex sets of information for at least 2000 years.</font></span></li></ul><li><span style="font-size: 12px; font-style: italic; text-decoration: underline;"><font face="Times New Roman">Formalize contracts between communicating classes.</font></span></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Assign responsibilities.</span><span style="font-size: 12px;"> This means thinking about how responsibilities should be assigned to objects.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Design for test.</span><span style="font-size: 12px;"> Think about what the system should look like to make testing it as easy as possible.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Avoid Failure.</span><span style="font-size: 12px;"> </span><span style="font-size: 12px; font-style: italic;">Design Paradigms: Case Histories of Error and Judgment in Engineering (Petroski 1994)</span><span style="font-size: 12px;"> chronicles the history of failure in bridge design. Argues many bridge failures have occurred because of focusing on previous successes and not adequately considering possible failure modes.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Focus on how your design may fail, don’t just copy other successful designs.</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Choose binding time consciously</span><span style="font-size: 12px;">. Code that binds early tends to be simpler, but it also tends to be less flexible.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Make Central Points of Control</span><span style="font-size: 12px;">.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">The principle of One Right Place: There should be One Right Place to look for any nontrivial piece of code, and One Right Place to make a likely maintenance change.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">So, centralize control</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Consider using brute force</span><span style="font-size: 12px;">.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">A brute force solution that works is better than an elegant solution that doesn’t work.</font></span></li></ul><li><span style="font-size: 12px; font-style: italic; text-decoration: underline;"><font face="Times New Roman">Draw a Diagram</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">A picture is worth 1000 words — kind of.</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Keep design modular</span><span style="font-size: 12px;">. </span></font></li></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Design Practices</font></span></div><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Iterate</span><span style="font-size: 12px;">.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Design is an iterative process.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Many people have trouble ranging between high level and low-level considerations.</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Divide and conquer</span><span style="font-size: 12px;">. </span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Top-Down and Bottom-Up Design Approaches</span><span style="font-size: 12px;">.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Top-down design begins at a high level of abstraction</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Bottom-up design starts with specifics and works toward generalities</font></span></li><li><span style="background-color: rgb(255, 250, 165); font-size: 12px; font-style: italic;-evernote-highlight:true;"><font face="Times New Roman">Arguments for top down</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Human mind can concentrate on only so much detail at a time</font></span></li></ul><li><span style="background-color: rgb(255, 250, 165); font-size: 12px; font-style: italic;-evernote-highlight:true;"><font face="Times New Roman">Arguments for bottom up</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">The top down approach might be to abstract to even get started, if you need something more tangible, try bottom up</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Good for early identification of utility functions</font></span></li></ul><li><span style="background-color: rgb(255, 250, 165); font-size: 12px; font-style: italic;-evernote-highlight:true;"><font face="Times New Roman">Things to keep in mind if you take the bottom up approach</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Ask yourself what you know the system needs to do</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Identify concrete objects and responsibilities from that question</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Identify common objects, and group them using subsystem organization, packages, composition within objects, or inheritance</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Continue with the next level up, or go back to the top and try to work your way back down</font></span></li></ul></ul><li><font face="Times New Roman"><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">Experimental Prototyping</span><span style="font-size: 12px;">.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Sometimes you cannot know if a design will work until you better understand some implementation detail.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">To address these issues, employ experimental prototyping</font></span></li><li><font face="Times New Roman"><span style="font-size: 12px;">Prototyping works poorly when developers aren’t disciplined about writing the </span><span style="font-size: 12px; font-style: italic; text-decoration: underline;">absolute minimum</span><span style="font-size: 12px;"> of code needed to answer a question</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px;">Prototyping also works poorly when the design question is not </span><span style="font-size: 12px; font-style: italic; text-decoration: underline;">specific</span><span style="font-size: 12px;"> enough.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px;">Prototyping code must be treated as </span><span style="font-size: 12px; font-style: italic; text-decoration: underline;">throwaway code</span><span style="font-size: 12px;">. One way to achieve this is to write prototypes in a completely different framework/language than the one used for the whole system.</span></font></li></ul><li><font face="Times New Roman"><span style="background-color: rgb(255, 250, 165); font-size: 12px; font-style: italic;-evernote-highlight:true;">Collaborative Design</span><span style="font-size: 12px;">.</span></font></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Two heads are often better than one. Forms of collaboration:</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Informally walk over to a co-worker and ask to bounce some ideas around</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">You and your co-worker sit together in a conference room and draw design alternatives on a whiteboard</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">You and your co-worker sit together at the keyboard and do detailed design in the programming language you’re using (i.e. pair programming)</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">You schedule a meeting to walk through your design ideas with one or more co-workers.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">You schedule a formal inspection</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">Do some work, put it into a drawer, and consult yourself a week later about your work.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">You ask someone outside your company for help: send questions to a specialized forum or newsgroup.</font></span></li></ul></ul><li><span style="background-color: rgb(255, 250, 165); font-size: 12px; font-style: italic;-evernote-highlight:true;"><font face="Times New Roman">How much design is enough?</font></span></li><ul><li><span style="font-size: 12px;"><font face="Times New Roman">Depends on the experience of the team, expected lifetime of the system, desired level of reliability, and size of project and team</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">If I can’t decide how deeply to investigate a design before I begin coding, I tend to err on the side of going into more detail.</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">I rarely encounter projects that are suffering from having done too much design work</font></span></li><li><span style="font-size: 12px;"><font face="Times New Roman">On the other hand, I have seen projects that are suffering from too much design documentation. Polished documentation is not paramount for design itself.</font></span></li></ul><li><font face="Times New Roman"><span style="font-size: 12px;">Aside from capturing design work in a formal document, you can </span><span style="font-size: 12px; background-color: rgb(255, 250, 165); font-style: italic;-evernote-highlight:true;">capture designs in numerous alternative ways</span><span style="font-size: 12px;">:</span></font></li><ul><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Insert design documentation into the code itself</span><span style="font-size: 12px;">. Document key design decisions in code comments, typically in class and file headers. Improves the chance programmers will keep the design documentation reasonably up to date.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Capture design discussions and decisions on a Wiki</span><span style="font-size: 12px;">. Have your design discussion in writing, on a project Wiki. Supplement text with pictures.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Write email summaries</span><span style="font-size: 12px;">. After a design discussion, adopt the practice of designating someone to write a summary of the discussion— especially what was decided— and send it to the project team. Archive a copy in the project’s public e-mail folder.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Use a digital camera</span><span style="font-size: 12px;">. Taking pictures of whiteboard drawings and embedding them into traditional documents can be a low-effort way to get 80 percent of the benefit of saving design drawings.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Save design flip charts</span><span style="font-size: 12px;">. The documentation need not only be set in letter paper.</span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Use CRC (Class, Responsibility, Collaborator) cards</span><span style="font-size: 12px;">. </span></font></li><li><font face="Times New Roman"><span style="font-size: 12px; font-style: italic; text-decoration: underline;">Create UML diagrams at appropriate levels of detail</span><span style="font-size: 12px;">.</span></font></li></ul></ul><div><font face="Times New Roman"><br/></font></div><div><span style="font-size: 12px; font-weight: bold;"><font face="Times New Roman">Comments on Popular Methodologies</font></span></div><ul><li><span style="font-size: 12px;"><font face="Times New Roman">The more dogmatic you are about applying a design method, the fewer real-life problems you are going to solve.</font></span></li></ul><div><br/></div></body></html>
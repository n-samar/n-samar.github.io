<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-13 22:14:59 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-14 01:51:47 +0000"/><title>SV: Ch 15 -- Dependability and Security Assurance</title></head><body><hr/><div><span style="font-weight: bold;"><font face="Times New Roman" style="font-size: 12px;">Sommerville: Chapter 15 — Dependability and Security Assurance</font></span></div><hr/><div><ul><li><font face="Times New Roman" style="font-size: 12px;"><i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Why do critical systems require particularly stringent testing and analysis?</i></font></li><ul><li><font face="Times New Roman" style="font-size: 12px;"><i style="">Costs of failure</i>. The costs and consequences of critical systems failure are potentially much greater than for non-critical systems.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><i>Validation of dependability attributes</i>. You must make a formal case to customers and a regulator that the system meets its specified dependability requirements. </font></li></ul></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div></div><div><font face="Times New Roman" style="font-size: 12px;"><b>15.1 Static analysis</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">System verification techniques that don’t involve executing a program.<br/></font></li><li><font><font face="Times New Roman" style="font-size: 12px;"><i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Statical analysis techniques</i> for critical systems:</font></font></li><ul><li><font><font face="Times New Roman" style="font-size: 12px;">Formal verification, where you produce mathematically rigorous arguments that a program conforms to its specification.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">Model checking, where a theorem prover is used to check a formal description of the system for inconsistencies.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">Automated program analysis, where the source code of a program is checked for patterns that are known to be potentially erroneous.</font></font></li></ul></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>Verification and formal methods</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;"><i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"/><i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Formal methods may be used at different stages</i> in the Validation &amp; Verification process:<br/></font></li><ul><li><font><font face="Times New Roman" style="font-size: 12px;">A formal specification of the system may be developed and mathematically analyzed for inconsistency.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">You can formally verify, using mathematical arguments, that the code of a software system is consistent with its spec.</font></font></li></ul><li><font face="Times New Roman" style="font-size: 12px;">In a <i>transformational development process</i>, a formal specification is transformed through a series of representations to program code. One method to do this is called the <b>B method</b>.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><i>Formal specification and proof do not guarantee that the software will be reliable</i></span> in practical use because:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;">The specification may not adequately reflect the real requirements of system users.</font></li><li><font face="Times New Roman" style="font-size: 12px;">The proof may contain errors.</font></li><li><font face="Times New Roman" style="font-size: 12px;">The proof may make incorrect assumptions about the way that the system is used.</font></li></ul><li><font face="Times New Roman" style="font-size: 12px;">Many believe that due to high costs, similar reliability benefits can be achieved through cheaper techniques like inspection or system testing.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Still used to verify critical-safety and security-critical components.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>Model checking</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">Involves creating a model of a system and checking the correctness of that model using specialized software tools.<br/></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">The model-checking process involves building a formal model of a system, usually as an extended finite state machine. A set of desirable system properties are identified and written in a formal notation, usually based on temporal logic.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">The model checker then explores all paths through the model (i.e. all possible state transitions), checking that the property holds for each path.</font></font></li><li><font face="Times New Roman" style="font-size: 12px;">Very useful for validation of concurrent systems.</font></li><li><font face="Times New Roman" style="font-size: 12px;">The Java Pathfinder system is an example of a model-checking system that works directly from a representation of Java code.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Since it is exhaustive, model checking is computationally expensive.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>Automatic static analysis</b></font></div></div></div></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">Some program errors and heuristics can be automatically checked.<br/></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">The most widely used static analysis technique, since it is easy to implement.<img src="SV%3A%20Ch%2015%20--%20Dependability%20and%20Security%20Assurance.resources/Screen%20Shot%202018-03-13%20at%203.42.37%20PM.png" height="356" width="597"/></font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;"><i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Three levels of checking</i> that may be implemented in static analyzers:</font></font></li><ul><li><font><font face="Times New Roman" style="font-size: 12px;"><i>Characteristic error checking</i>. At this level, the static analyzer knows about common errors that are made by programmers in languages such as Java or C. The tool analyzes the code looking for patters that are characteristic of that problem and highlights these to the programmer. 90% of all errors typically result from 10 types of characteristic errors.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;"><i>User-defined error checking</i>. Here, the users of the static analyzer may define error patterns, thus extending the types of error that may be detected. E.g. method A must be called before method B.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;"><i>Assertion checking</i>. The most general and most powerful approach to static analysis.</font></font></li></ul><li><font face="Times New Roman" style="font-size: 12px;">Static analysis is known to generate a large number of false positives — code section without error that the analyzer flags as potentially erroneous.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Very well suited for common security problems, e.g. buffer overflows.</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>15.2 Reliability testing</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">Testing process that aims to measure the reliability of a system<br/></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">POFOD: probability of failure on demand</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">ROCOF: rate of occurrence of failure</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">Process of <i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">measuring the reliability of a system (statistical testing)</i>:</font></font></li><ul><li><font style="font-size: 12px;"><font><font face="Times New Roman">Start by studying existing systems of the same type to understand how these are used in practice. This is important as reliability should be measured from the point of view of the user. An <b>operational profile</b> identifies classes of system inputs and the </font></font><font face="Times New Roman">probability that these inputs will occur in normal use.</font></font></li><li><font face="Times New Roman" style="font-size: 12px;">You then construct a set of test data that reflects the operational profile.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Test the data and count up the number and type of failures that occur.</font></li><li><font face="Times New Roman" style="font-size: 12px;">After observing a statistically significant number of failures, software reliability can be computed.</font></li></ul><li><font face="Times New Roman" style="font-size: 12px;">Statistical testing is not easy to apply in practice. Principal <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><i>difficulties with statistical testing</i></span>:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;"><i>Operational profile uncertainty</i>. The operational profile based on experience with other systems may not be an accurate reflection of the real use of the system.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><i>High costs of test data generation</i>. It can be very expensive to generate the large volume of data required in an operational profile.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><i>Statistical uncertainty when high reliability is required.</i> You need a statistically significant number of failures, which might take a lot of time to generate if system is already reliable.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><i>Recognizing failure</i>. It is not always obvious whether or not a system failure has occurred.</font></li></ul><li><font face="Times New Roman" style="font-size: 12px;"><b>Test data generators </b>can be used to automatically generate inputs matching the operational profile.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Statistical testing may be used together with fault injection to gather data about how effective the process of defect testing has been. Fault injection, however, is not effective in predicting the number of faults that stem from requirements or design errors..</font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>Operational profile</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">The operational profile of a software system reflects how it will be used in practice.<br/></font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>Security testing</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;"><i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Why security testing is difficult:</i><br/></font></li><ul><li><font><font face="Times New Roman" style="font-size: 12px;">Security requirements, like some safety requirements, are 'shall not' requirements. It is not usually possible to define this unwanted behavior as simple constraints to be checked by the system.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">The people attacking system are intelligent and are actively looking for vulnerabilities.</font></font></li></ul><li><font face="Times New Roman" style="font-size: 12px;">Attackers may try to discover the assumptions made by system developers and then contradict these assumptions to see what happens.</font></li><li><font face="Times New Roman" style="font-size: 12px;">For this reason, static analysis can be particularly useful as a security testing tool.</font></li><li><font face="Times New Roman" style="font-size: 12px;">To check the security of a system, you can <i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">use a combination of testing, tool-based analysis, and formal verification</i>:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;"><i>Experience-based testing</i>. The system is analyzed against types of attacks that are known to the validation team.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><i>Tiger teams</i>. A form of experience-based testing where it is possible to draw on experience from outside the development team to test and application system. The tiger team is given the objective of breaching the system security.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><i>Tool-based testing</i>. Various security tools such as password checkers are used to analyze the system. Password checkers detect insecure passwords.</font></li><li><font face="Times New Roman" style="font-size: 12px;"><i>Formal verification</i>. A system can be verified against a formal security specification. This is not widely used.</font></li></ul><li><font face="Times New Roman" style="font-size: 12px;"><i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Security checklist</i>:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;">Do all files that are created in the application have appropriate access permissions?</font></li><li><font face="Times New Roman" style="font-size: 12px;">Does the system automatically terminate user sessions after a period of inactivity?</font></li><li><font face="Times New Roman" style="font-size: 12px;">If the system is written in a programing language without array bound checking, are there situations where buffer overflow may be exploited?</font></li><li><font face="Times New Roman" style="font-size: 12px;">If passwords are set, does the system check that passwords are strong?</font></li><li><font face="Times New Roman" style="font-size: 12px;">Are inputs from the system’s environment always checked against an input specification?</font></li></ul></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>15.4 Process assurance</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">Dependable processes lead to dependable systems<br/></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">Evidence that a dependable process has been used increases overall confidence that a system is dependable.</font></font></li><li><font style="font-size: 12px;"><font><font face="Times New Roman">Process assurance is concerned with collecting information about processes used during system development, and the outcomes of these processes. This information provides evidence of the analyses, reviews, and tests that </font></font><font face="Times New Roman">have been carried out during software development.</font></font></li><li><font face="Times New Roman" style="font-size: 12px;">Process assurance is <i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">concerned with two things</i>:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;">Do we have the right processes?</font></li><li><font face="Times New Roman" style="font-size: 12px;">Are we doing the processes right?</font></li></ul></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>Processes for safety assurance</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">It is <i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">important that a safety-critical systems development process include Verification &amp; Validation</i> <i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">processes</i> that are geared to safety analysis and assurance because:<br/></font></li><ul><li><font><font face="Times New Roman" style="font-size: 12px;">Accidents are rare events in critical systems and it may be practically impossible to simulate them during the testing of a system. You can’t rely on extensive testing to replicate the conditions that can lead to an accident.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">Safety requirements are often ’shall not’ requirements that exclude unsafe system behavior. These requirements are very hard to test.</font></font></li></ul><li><font face="Times New Roman" style="font-size: 12px;"><i style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Safety assurance activities incorporated into software processes</i>:</font></li><ul><li><font face="Times New Roman" style="font-size: 12px;">Hazard logging and monitoring, which trace hazards from preliminary hazards analysis through to testing and system validation.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Safety reviews, which are used throughout the development process.</font></li><li><font face="Times New Roman" style="font-size: 12px;">Safety certification, where the safety of critical components is formally certified. This involves a group external to the system development team examining the available evidence and deciding whether or not a system or component should be considered to be safe before it is made available.</font></li></ul><li><font face="Times New Roman" style="font-size: 12px;">To support these safety assurance processes, project safety engineers should be appointed who have explicit responsibility for the safety aspects of a system.</font></li><li><font face="Times New Roman" style="background-color: rgb(255, 250, 165); font-size: 12px;-evernote-highlight:true;"><i>Why should individuals with safety responsibilities be explicitly identified?</i></font></li><ul><li><font face="Times New Roman" style="font-size: 12px;">When people are identified, they can be held accountable for their actions. </font></li><li><font face="Times New Roman" style="font-size: 12px;">In the event of an accident, there may be legal proceedings or an enquiry. The people held responsible will then have to account for their actions.</font></li></ul></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>15.5 Safety and dependability cases</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">Safety and dependability cases are structured documents setting out detailed arguments and evidence that a system is safe or that a required level of security or dependability has been achieved.<br/></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">A safety case is a document body of evidence that provides a convincing and valid argument that a system is adequately safe for a given application in a given environment.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">Dependability cases are generalizations of safety cases.</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">When constructing a software safety case, you have to relate software failures to wider system failures and demonstrate either that these software failures will not occur or that they will not be propagated in such a way that dangerous system failures may occur.</font></font></li><li><font face="Times New Roman" style="font-size: 12px;">Contents of safety case:<img src="SV%3A%20Ch%2015%20--%20Dependability%20and%20Security%20Assurance.resources/Screen%20Shot%202018-03-13%20at%206.34.02%20PM.png" height="440" width="561"/></font></li></ul><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><b>Structured arguments</b></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;">You start by assuming that an unsafe state, which has been identified by the system hazard analysis, can be reached by executing the program<br/></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">You write a predicate (logical expression) that defines this unsafe state</font></font></li><li><font><font face="Times New Roman" style="font-size: 12px;">You then systematically analyze a system model or the program and show that, for all program paths leading to that state, the terminating condition of these paths contradicts the unsafe state predicate.</font></font></li></ul><font face="Times New Roman" style="font-size: 12px;"><b/></font></div><font face="Times New Roman" style="font-size: 12px;"><b/></font></div><font face="Times New Roman" style="font-size: 12px;"><b/></font></div><font face="Times New Roman" style="font-size: 12px;"><b/></font></div><font face="Times New Roman" style="font-size: 12px;"><b/></font></div><font face="Times New Roman" style="font-size: 12px;"><b/></font></div><font face="Times New Roman" style="font-size: 12px;"><b/></font></div><font face="Times New Roman" style="font-size: 12px;"><b/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><img src="SV%3A%20Ch%2015%20--%20Dependability%20and%20Security%20Assurance.resources/Screen%20Shot%202018-03-13%20at%206.39.23%20PM.png" height="520" width="562"/></font></div><div><font face="Times New Roman" style="font-size: 12px;"><br/></font></div><div><ul><li><font face="Times New Roman" style="font-size: 12px;"><font>Structured arguments can be used in the same way to demonstrate that certain </font>security properties of a system are true. However, the evidence from structured arguments is less reliables because there is a possibility that the attacker may corrupt the code of the system.<br/></font></li></ul></div><div><br/></div></body></html>
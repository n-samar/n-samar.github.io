<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.0.2 (456266)"/><meta name="author" content="NIKOLA SAMARDZIC"/><meta name="created" content="2018-03-09 05:30:27 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-03-09 05:30:59 +0000"/><title>Ch 3 -- Transport Layer</title></head><body><div><br/></div><hr/><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Chapter 3 — Transport Layer</span></div><hr/><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Transport Layer Services</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Takes information from edge systems to actual application sockets</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Implemented only in the end systems (not in routers)</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Transport-layer packets are called </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">segments</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Network routers only interface with packets on the network layer (no transport layer interaction)</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP and UPD are examples of Transport Layer protocols</span></li></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Relationship Between Transport and Network Layers</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Transport layer protocol provides logical communication between </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">processes</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> running on different hosts</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Network paler protocol provides logical communication between </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">hosts</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The services of the transport layer protocol are often constrained by the service model of the underlying network layer protocol.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Datagrams</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> are network layer packets.</span></li></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Overview of the Transport Layer in the Internet</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP/IP refers to two protocols:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">TCP</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> — Internet’s transport layer protocol</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">IP (Internet Protocol)</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> — Internet’s network layer protocol</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">IP is a </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">best-effort delivery service</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. i.e. inherently unreliable:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">no guarantee of segment delivery</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">no guarantee of orderly segment delivery</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">no guarantee of data integrity within segments</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">IP address</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> is a unique network layer address of each host connected to the internet.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP extends IP’s delivery service between two end systems to a delivery service between two processes running on the end systems</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Extending host-to-host delivery to process-to-process delivery is called </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">transport-layer multiplexing</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> or </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">demultiplexing</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP is more reliable than UDP:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">reliable data transfer</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: correct and in-order delivery</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">congestion control</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: prevents any one TCP connection from swamping the links and routers between communicating hosts with an excessive amount of traffic. A service for the Internet (rather than applications connected to it)</span></li></ul></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Multiplexing and Demultiplexing</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Socket</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: a passage for information from and to the application and network layer.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Segments (transport layer packets) include data about the sending and receiving </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">port numbers</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Port numbers between 0 and 1023 are called </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">well-known port numbers</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> and are restricted.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Trasport layer is responsible for assigning port numbers to each newly created socket automatically. </span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP socket is identified by a four-touple (vs. a UDP socket which is just identified by source and destination port numbers):</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">source IP address</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">source port number</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">destination IP address</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">destination port number</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Walkthrough of TCP connections:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The TCP server application has a </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">welcoming socket</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> which waits for connection establishment requests from TCP clients on port number 12000.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The TCP client creates a socket and sends a connection establishment request segment</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Once the host operating system of the server process receives the connection-request segment with destination port 12000, it locates the sever process that is waiting to accept a connection on port number 12000 and creates a new socket for it</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The server’s transport layer notes the four-toupee provided by the incoming connection-request. This four-touple is matched to the newly created socket and all data incoming with that four-touple value will be multiplexed to the newly created socket by the transport layer of the host running the server process.</span></li></ul></ul><div><img src="Ch%203%20--%20Transport%20Layer.resources/Screen%20Shot%202018-01-30%20at%202.03.14%20PM.png" height="565" width="793"/></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Above image illustrates how we can communicate with the same port number on server from the same port number on two different clients with TCP because TCP sockets keep track of IP addresses of the client.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Servers today usually accept new TCP connections by creating a new thread, but respond to the connection through the same mother process.</span></li></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">UDP</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">At the very list a transport layer protocol must provide a multiplexing/demultiplexing service in order to pass data between the network layer and the correct application-level process</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">With UDP, the application is almost talking directly to IP (aside from the addition of source and destination port and two other fields)</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Since there is no handshaking between destination and source, UPD is said to be </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">connectionless</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">DNS uses UDP.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Why might an application be better suited for UDP?</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">Finer application-level control over what data is sent and when.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">No connection establishment. </span><span style="font-size: 12px; font-family: 'Helvetica Neue';">That is, no overhead. This is why DNS runs UDP, it is much faster.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">No connection state.</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> TCP maintains connection state in the end systems. This includes:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">receive/send buffers</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">congestion-control parameters</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">sequence and acknowledgment number parameters</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">Minimal packet header overhead.</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> (8 bytes specifically)</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">A </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">checksum</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> can be used to ensure full transmission of data over UDP (also detects any other form of corruption).</span></li></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Principles of Reliable Data Transfer</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Pivotal issue in networking</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Means all data is delivered in order it is sent and without any corruption</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Positive acknowledgments</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: acknowledge each understandable packet that is transmitted </span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Negative acknowledgments</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: acknowledge each non-understandable packet that is transmitted</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">ARQ (Automatic Repeat reQuest) protocols</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Protocols that rely on positive and negative acknowledgments.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">To handle bit errors with ARQ we need some additional protocol capabilities:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Error detection</span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">. </span><span style="font-size: 12px; font-family: 'Helvetica Neue';">A mechanism that allows the receiver to detect when bit errors have occurred. This usually means extra corruption detection bits need to be sent through</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Receiver feedback</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. A mechanism that allows the receiver to respond to sender with acknowledgments.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Retransmission</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. A mechanism for sender to resend data that received negative acknowledgments.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Note that while the sender is waiting for an acknowledgment it cannot send any packets.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">How to handle corruption of acknowledgments?</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">We must have a checksum</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">But, the sender also must notify the receiver that there was a problem with the acknowledgment. Possible solutions:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Add a protocol in which the sender could ask the receiver “What did you say?”. This is subject to corruption as well, though.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Add enough checksum data that the sender will be able to recover from data correction locally.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Have the sender resend the current data packet when it receives corrupted acknowledgment. But, receiver cannot </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">a priori </span><span style="font-size: 12px; font-family: 'Helvetica Neue';">conclude whether a packet is a retransmission or new packet.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Most used solution uses </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">sequence number</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: a number which specifies which orders packets being sent in a single TCP connection. This would allow the receiver to deduce whether the message is a retransmission or not. Instead of using negative and positive acknowledgment messages, the receiver can respond to a message with an acknowledgment with the sequence number of the last successfully transmitted packet. So, no need for specific negative acknowledgments.</span></li></ul></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">How to deal with packet loss?</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Alternating-bit protocol</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: Put burden of detecting and recovering from packet loss on the sender and have it retransmit a packet if no acknowledgment is received in a specified time frame. Waiting time for resending needs to be balanced between overloading the network with duplicate packets and waiting too long to transmit packets that are actually lost.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Still have problem: Alternating-bit protocol is a </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">stop-and-wait protocol</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> (waits for acknowledgments).</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Pipelining</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: Send a couple (e.g. 3) packets before waiting for acknowledgments. This effectively triples the throughput of the connection. </span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Consequences to reliability of pipelining:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The range of sequence numbers must be increased</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The sender and receiver sides of the protocols may have to buffer more than one packet. E.g. the sender will have to buffer packets that have been transmitted but not yet acknowledged.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Pipelined error recovery methods are required</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Go-Back-N</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Selective repeat</span></li></ul></ul></ul><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Go-Back-N</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Go-Back-N</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. The sender can send up to N packets without acknowledgments. N is referred to as the </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">window size</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">, and GBM is called the </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">sliding-window protocol</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The GBN sender must respond to three types of events:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Invocation from above</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. When a send request is called from the application layer, GBN will first look if there are less than N outstanding sent packets. If the window is full, the sender simply returns the data back to the application layer.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Receipt of acknowledgment</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Acknowledgments are usually taken cumulatively, i.e. if the sender receives acknowledgment with sequence number K, it is considered that all packets with sequence number K or less are received successfully. This is called </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">cumulative acknowledgment</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">A timeout event</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. If timeout occurs, the sender resends all packets that have been previously sent but that have not yet been acknowledged. We use only a single timer, the timer reflects the timeout time of the oldest transmitted package that has not been acknowledged yet. If there are no unacknowledged packets, the timer is stopped.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The GBN receiver must do the following:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">If packet with sequence number K is received, and all packages with sequence number less than K have been received, respond with acknowledgment with sequence number K.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Otherwise, respond with acknowledgment of most recent in-order received packet. This ensures </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">in-order transmission</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li></ul></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Selective Repeat (SR)</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Selective-repeat protocols avoid unnecessary retransmissions by having the sender retransmit only those packets that it suspects were received in error at the receiver.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Requires that the receiver individually acknowledge each correctly received packet</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Windows are still used to limit number of unacknowledged packets in pipeline.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Acknowledges packets whether or not they are in order. Out-of-order packets are buffered until any missing packets are received at which point a batch of packets is sent to the application layer.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Sender events and actions include:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">Data received from above. </span><span style="font-size: 12px; font-family: 'Helvetica Neue';">Check first available sequence number for packet. If it is within the window, packetize and send; otherwise either buffer or return to application layer.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">Timeout. </span><span style="font-size: 12px; font-family: 'Helvetica Neue';">Each packet must have it’s own timer. Of course, this can be implemented with only one real hardware timer.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">Acknowledgment received.</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> Mark acknowledged packets with a received flag. If packet’s sequence number is equal to the base of the window, increase the base to first unacknowledged sequence number, transmit any packets that now entered the window.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Receiver events and actions include:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">Packet received. </span><span style="font-size: 12px; font-family: 'Helvetica Neue';">If packet is within receiver window, send appropriate acknowledgment back to sender. If packet was not already received, put into buffer. If the sequence number of the packet is equal to the base of the receiver window, then deliver this and any sequenced buffered packets until the first not received packet to the application layer and move the window to this not received packet.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">Packet with smaller number than window base received.</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> In this case, just send back acknowledgment with appropriate sequence number.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">Otherwise. </span><span style="font-size: 12px; font-family: 'Helvetica Neue';">Ignore packet.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The window size for SR must be equal to half or less of the size of the sequence number space.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Since sequence numbers are reused, it is very important to ensure that the sent sequence numbers are no longer in the network before they are reused. This is because a very old packet can reach the receiver a lot later than expected and out of the sending order while the receiver is expecting a new packet with the same sequence number but different content. In practice, packets do not persist in the network for more than 3 minutes, so this is considered as a safe threshold for sequence number reuse.</span></li></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">TCP Connection</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP is called </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">connection-oriented</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> due to the handshake prerequisite.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The intermediate network elements (between two end-points) do not maintain the TCP connection. TCP lives strictly within the two end-points. That is, the intermediate network routers are completely oblivious to existence of TCP connections and only see network datagrams.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Full-duplex service</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: Communication on established TCP connection is bi-directional.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Point-to-point</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: 1 sender and 1 receiver.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Three-way handshake</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Data is sent by the application layer to into a </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">send buffer</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> and TCP takes care of the rest.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Maximum segment size (MSS)</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> limits size of segments sent by TCP connection. Usually bounded by the link-layer frame size limits.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP pairs each chunk of client data with a TCP header, thereby forming a </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">TCP segment</span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic;">.</span></li></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">TCP Segment Structure</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP segment headers include:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">32-bit </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">sequence number field</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">32-bit </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">acknowledgment number field</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">16-bit </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">receive window</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Specifies number of bytes receiver is willing to receive.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">4-bit </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">header length field</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Specifies the length of the TCP header in 32-bit words.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">A variable length </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">options field</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Used when sender and receiver negotiate the maximum segment size or window scaling factor for high-speed networking.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Flag field</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> contains 6 bits.</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">ACK bit</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: indicates that the acknowledgment field is valid</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">RST</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">, </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">SYN</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">, </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">FIN</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> used for connection setup, teardown.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">PSH</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Indicates data should be sent to receiver’s application layer as soon as it is received by its TCP.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">URG</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Used to indicate that there is data in this segment that the sending-side application layer marked urgent.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Urgent data pointer field</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Points to urgent data location in case URG is set.</span></li></ul></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP in Host A will implicitly number each byte in the data stream. The first segment gets assigned a sequence number 0 by the sender. If MSS is 1000, the sender will label the next segment with sequence number 1000, designating the first byte of the data stream in the second segment.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The acknowledgment number that Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Uses </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">cumulative acknowledgments</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Although not specified in the RFC, data received out of order is usually buffered on the receiver size and kept in the buffer until the gaps between the data are filled.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Due to the fact that TCP is bidirectional, acknowledgments are </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">piggybacked</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> on actual messages.</span></li></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Round-Trip Time Estimation and Timeout</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP constantly measures RTT times to be able to estimate RTT and compute the timeout window.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Use </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">exponential weighted moving average</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> to compute the current RTT estimate.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Also, TCP keeps track of the variance of RTT measurements</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">timeout</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> is calculated as &lt;estimated RTT&gt; + 4 * &lt;estimated deviation&gt;</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Each time TCP retransmits it sets the timeout to double of the current value. This is done to ease congestion and not pressure the network with additional data.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">How to notice lost/corrupted receives fast in the sender?</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The sender usually sends many packets one after the other, since TCP uses cumulative acknowledgments, if one packet is lost, the sender will receive multiple acknowledgments from the sender specifying that it expects the same bit each time.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">If 3 acknowledgments with the same sequence number are sent, TCP will use </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">fast transmission</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">, i.e. it will transmit the package with the acknowledgment’s sequence number again before the segment’s timer expires.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Although TCP is principally GBN, it has some differences:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP implementations usually buffer correctly received but out-of-order segments</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">If segment N+1’s acknowledgment is received by the sender before the expiration of N’s timeout, packet N will not be resent to the receiver (while GBN will resend all packets greater than N). Further, even if the timer for N expires, TCP will only send packet N and will not assume anything about the state of packets greater than N.</span></li></ul></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">TCP Flow Control</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP has both a receiver and sender buffer. It is the responsibility of the application layer to read the receiver buffer and therefore allow TCP to clear the buffer for new data. Sometimes, the applications using a TCP connection do not read the received data for a long time.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP places correctly received, in-order packets into the buffer.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">It is crucial that the receive buffer doesn’t overflow.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">How does TCP provide flow control? (assume out of order packets are discarded for simplicity)</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Sender maintains a </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">receive window</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">, which informs the sender how much free buffer space is available at the receiver.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Sender is responsible for keeping the amount of unacknowledged data lower than the available space in the receiver’s buffer.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">If the receiver’s receive window goes down to 0, the sender still sends one 1 byte messages just for the purpose of getting a response from the receiver about the size of its receive window.</span></li></ul></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">TCP Connection Management</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Which steps are involved in establishing a TCP connection?</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The client sends out a message to the server establishing intent to make a connection with a specific process on the server.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The client-side TCP sends a special TCP segment to the server-side TCP (contains no application layer data), but the SYN bit is set to 1 (called a </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">SYN segment</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">). Also, client randomly chooses an initial sequence number and puts this number in the sequence number field of the initial SYN segment.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Once the SYN segment arrives at the server host, the server allocates the TCP buffers and variables to the connection, and sends a </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">connection-granted segment (SYNACK segment)</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> to the client TCP. The server also sends its own initial sequence number through this connection-granted segment.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Once the client receives the SYNACK segment, it allocates required buffers and variables on its side. The client then sends the server another segment acknowledging the server’s connection-granted segment by setting the value of the acknowledgment field appropriately. This stage of the three-way handshake may carry client-to-server data in the segment payload.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">When a TCP connection is closed:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">All resources associated with the connection are deallocated</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">How is TCP close facilitated (assuming client closes connection)?</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Client application layer issues close command</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Client sens special TCP segment with FIN bit set to 1</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Server sends back acknowledgment segment and a shutdown segment with the FIN bit set to 1.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Client acknowledges server’s shutdown segment.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">All resources related to the connection are deallocated for both server and client.</span></li></ul></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Principles of Congestion Control</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Large queuing delays are experienced as the packet-arrival rate nears the link capacity</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">The sender must perform retransmissions in order to compensate for dropped packets due to buffer overflow.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">When a packet is dropped along a path, the transmission capacity that was used at each of the upstream links to forward that packet to the point at which it is dropped ends up having been wasted.</span></li></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">Approaches to Congestion Control</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Two types of congestion control:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">End-to-end congestion control</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Network layer provides no explicit support to the transport layer for congestion control purposes. The congestion state must be inferred from amount of packet loss or delay. This is essentially the only way TCP can do congestion control since IP does not provide any congestion data to transport layer. TCP segment loss is taken as an indication of network congestion and TCP decreases its window size accordingly.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Network-assisted congestion control</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Here, network layer components (i.e., routers) provide explicit feedback to the sender regarding the congestion state of the network.</span></li></ul></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">ATM ABR Congestion Control</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Network-assisted approach to congestion control</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Interspersed with the data cells are </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">resource-management (RM) cells</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> used to convey congestion-related information among the hosts and switches.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Switches can also generate RM cells and send them into the network themselves.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">ABR provides three mechanisms for signaling congestion-related information from the switches to the receiver:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">EFCI bit</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Each data cell contains an explicit forward congestion indication. A congested network switch can set the EFCI bit in a data cell to 1 to signal congestion to the destination host. Once this reaches the receiver, it sends it back to the sender. These EFCI bits are sent out in </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">RM cells</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">, which are interspersed with data packets.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">CI and NI bits</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Switch in network can set NI bit to 1 under mild congestion and set the CI bit to 1 under sever congestion conditions.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">ER setting</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Each RM cell also contains a 2-byte </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">explicit rate (ER) field</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. A congested switch may lower the value contained in the ER field in a passing RM cell. In this manner, the ER field will be set to the minimum supportable rate of all switches on the source-to-destination path.</span></li></ul></ul><div><br/></div><div><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-weight: bold;">TCP Congestion Control</span></div><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">If the sender perceives the network to be congested, it will reduce its send rate. If it perceives little congestion, it will increase its send rate.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Congestion window</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">: imposes constraint on the amount of unacknowledged data the sender can send (note that the amount of unacknowledged data is also limited by the receive window).</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">By adjusting the congestion window the load of the specific TCP connection on the network can be lowered.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">In case of no congestion, TCP will increase the size of the congestion window relative to the amount of time required for an acknowledgment to be received by the sender.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP guidelines for determining how much the connection should load the network:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">A lost segment implies congestion, and hence, the TCP sender’s rate should be decreased when a segment is lost.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Acknowledged segments imply that the sender’s rate can be increased.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Bandwidth probing</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Keep increasing bandwidth until a packet loss event occurs.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">TCP congestion-control algorithm</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">. Three major components:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">slow start</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">congestion avoidance</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">fast recovery</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Slow start</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">initialize congestion window to small initial size (e.g. 1 MSS) so initial sending rate is roughly MSS/RTT.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Keep increasing cwindow by 1 MSS every time a packet is successfully acknowledged (effectively doubling the window every RTT assuming infinite bandwidth).</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">In case of packet loss, set window back to 1 MSS and start again and sets the </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">slow start threshold</span><span style="font-size: 12px; font-family: 'Helvetica Neue';"> to half of the window size of when the packet loss occurred. </span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Once the slow start threshold is reached, TCP switches into congestion avoidance mode and is no longer in slow start mode.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">In case three duplicate acknowledgments are sent, TCP does a fast retransmit and enters the </span><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">fast recovery state</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Congestion avoidance:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">Consists of increasing the congestion window by only a single MSS per successful transmission iteration once the slow start threshold is reached in slow start mode.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">In case of packet loss, the congestion window is again reduced to 1 MSS and the value of the slow start threshold is reset to half of the window size at the point of packet loss. </span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">In case of a triple duplicate acknowledgment, TCP halves the size of the congestion window and slow start threshold reset to this halved value. The fast-recovery state is then entered.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue'; font-style: italic; text-decoration: underline;">Fast Recovery</span><span style="font-size: 12px; font-family: 'Helvetica Neue';">:</span></li><ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">increase the congestion window by 1 MSS for every duplicate acknowledgment received for the missing segment that caused TCP to enter the fast-recovery state.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">when the acknowledgment of the missing packet arrives eventually, TCP enters the congestion-avoidance state after deflating the congestion window.</span></li><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">in case of a timeout event (packet loss), fast recovery transitions to the slow start state after setting the congestion window to 1 MSS, and the slow start threshold to half the value of the congestion window when the loss occurred.</span></li></ul><li><span style="font-size: 12px; font-family: 'Helvetica Neue';">TCP congestion control is generally considered to be fair.</span></li></ul><div><br/></div></body></html>